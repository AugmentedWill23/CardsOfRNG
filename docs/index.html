<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rarity Roll Game â€“ StarForged V13 (Refactored)</title>

    <!-- Link to external CSS -->
    <style>
                /* Futuristic UI Style - Refactored CSS */

/* --- Variables --- */
:root {
    --primary-font: 'Roboto', sans-serif;
    --title-font: 'Orbitron', sans-serif;

            /* Dark Theme Palette */
            --bg-gradient-start: #0f0c29;
            --bg-gradient-end: #302b63;
            --bg-gradient-mid: #24243e;
            --container-bg: rgba(18, 18, 40, 0.85);
            --container-border: rgba(0, 191, 255, 0.3);
    --text-color: #e0e0e0;
            --text-secondary: #a0a0c0;
            --heading-color: #00e5ff;
            --accent-color: #00e5ff;
            --accent-hover: #80faff;
            --secondary-color: #6a0dad;
            --secondary-hover: #8a2be2;
            --danger-color: #ff3366;
            --danger-hover: #ff6699;
            --success-color: #00ff99;
            --success-hover: #66ffcc;
            --info-color: #00aaff;

            /* UI Elements */
            --input-bg: rgba(0, 0, 20, 0.6);
            --input-border: rgba(0, 191, 255, 0.4);
    --input-focus-border: var(--accent-color);
            --input-focus-shadow: 0 0 15px rgba(0, 229, 255, 0.6);

            /* Cards & Popups */
            --card-bg: rgba(25, 25, 60, 0.8);
    --card-border: var(--accent-color);
            --card-back-bg: rgba(40, 40, 80, 0.85);
            --popup-bg: rgba(15, 15, 35, 0.97);
            --popup-border: var(--accent-color);
            --overlay-bg: rgba(0, 0, 0, 0.9);

            /* Effects */
            --glow-color-accent: rgba(0, 229, 255, 0.7);
            --glow-color-secondary: rgba(138, 43, 226, 0.6);
            --glow-color-danger: rgba(255, 51, 102, 0.6);
            --glow-color-success: rgba(0, 255, 153, 0.6);
            --box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            --text-glow-accent: 0 0 5px var(--accent-hover), 0 0 10px var(--accent-hover);
            --backdrop-blur: 5px;

            /* Misc */
            --border-radius: 6px;
            --transition-speed: 0.3s;
    --scrollbar-thumb: var(--accent-color);
    --scrollbar-track: var(--input-bg);
}

/* --- Global Styles --- */
*,
*::before,
*::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: var(--primary-font);
            background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-mid), var(--bg-gradient-end));
    color: var(--text-color);
    line-height: 1.6;
    padding: 1rem;
    transition: background var(--transition-speed);
            overflow-x: hidden;
            min-height: 100vh;
}

.container {
            max-width: 1100px;
            margin: 30px auto;
            padding: 30px;
    border-radius: var(--border-radius);
    background: var(--container-bg);
            border: 1px solid var(--container-border);
            box-shadow: var(--box-shadow), 0 0 50px rgba(0, 0, 0, 0.5) inset;
            -webkit-backdrop-filter: blur(var(--backdrop-blur));
            backdrop-filter: blur(var(--backdrop-blur));
    transition: max-width var(--transition-speed);
}

        h1,
        h2,
        h3 {
            margin: 1.5rem 0 1rem;
    text-align: center;
    color: var(--heading-color);
    font-family: var(--title-font);
    font-weight: 700;
            text-shadow: 0 0 8px var(--glow-color-accent);
            letter-spacing: 1px;
        }

        h1 {
            font-size: 2.2rem;
        }

        h2 {
            font-size: 1.8rem;
        }

        h3 {
            font-size: 1.4rem;
        }

        hr {
            border: none;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
            margin: 20px 0;
            opacity: 0.5;
        }

/* --- Utility Classes --- */
.hidden {
            display: none !important;
}

        /* Use !important sparingly, but useful here */
.active {
            display: block;
}

        /* Generic active class */
.screen {
            display: none;
}

        /* Base state for screens */
.screen.active {
    display: block;
}

        /* Active screen is displayed */

/* --- UI Toggle --- */
.ui-toggle {
    text-align: right;
    margin-bottom: 1rem;
}

/* --- Input Fields & Forms --- */
input[type="text"],
input[type="password"],
input[type="number"],
        input[type="email"],
select {
            padding: 12px 18px;
            margin: 10px 0;
    width: 100%;
    border-radius: var(--border-radius);
            border: 1px solid var(--input-border);
    background-color: var(--input-bg);
    color: var(--text-color);
    font-size: 1rem;
    font-family: var(--primary-font);
    outline: none;
            transition: border-color var(--transition-speed), box-shadow var(--transition-speed), background-color var(--transition-speed);
}

input:focus,
select:focus {
    border-color: var(--input-focus-border);
            background-color: rgba(0, 20, 40, 0.7);
            box-shadow: var(--input-focus-shadow);
        }

        select {
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%2300e5ff" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat;
            background-position: right 15px center;
            padding-right: 40px;
        }

        select option {
            background: #1a1a3a;
            color: var(--text-color);
}

label {
    margin-right: 15px;
    display: inline-block;
    vertical-align: middle;
            color: var(--text-secondary);
            font-size: 0.9rem;
}

input[type="radio"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            display: inline-block;
    vertical-align: middle;
            margin-right: 5px;
            position: relative;
            cursor: pointer;
            transition: background-color var(--transition-speed), box-shadow var(--transition-speed);
        }

        input[type="radio"]:checked {
            background-color: var(--accent-color);
            box-shadow: 0 0 5px var(--glow-color-accent);
        }

        input[type="radio"]:checked::after {
            content: '';
            display: block;
            width: 6px;
            height: 6px;
            background: var(--container-bg);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #loginForm {
            max-width: 450px;
            margin: 40px auto;
            padding: 30px;
            border: 1px solid var(--container-border);
            border-radius: var(--border-radius);
            background: rgba(0, 0, 10, 0.5);
}

#loginForm .login-actions {
            margin: 20px 0;
    text-align: center;
}

        #loginForm h2 {
            margin-top: 0;
}

/* --- Buttons --- */
        button,
        .btn {
            /* Add .btn class for consistency */
            padding: 12px 25px;
            border: 1px solid transparent;
    border-radius: var(--border-radius);
    color: #fff;
    cursor: pointer;
    font-size: 1rem;
            font-family: var(--title-font);
            font-weight: 500;
            transition: background-color var(--transition-speed), border-color var(--transition-speed), color var(--transition-speed), transform 0.1s, box-shadow var(--transition-speed);
    width: auto;
            margin: 8px;
    display: inline-block;
    text-align: center;
    vertical-align: middle;
            background-color: var(--secondary-color);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        button:hover,
        .btn:hover {
            background-color: var(--secondary-hover);
            border-color: var(--accent-hover);
            box-shadow: 0 0 10px var(--glow-color-secondary);
            color: var(--accent-hover);
            transform: translateY(-2px);
        }

        button:active,
        .btn:active {
            transform: scale(0.98) translateY(0);
            box-shadow: 0 0 5px var(--glow-color-secondary);
        }

        button:disabled,
        .btn:disabled {
            background-color: rgba(80, 80, 100, 0.5);
            border-color: rgba(100, 100, 120, 0.4);
            color: var(--text-secondary);
    cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
            transform: none;
}

        /* Button Variants */
.btn-primary {
    background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: var(--container-bg);
            font-weight: bold;
}

.btn-primary:hover {
    background-color: var(--accent-hover);
            border-color: var(--accent-hover);
            box-shadow: 0 0 15px var(--glow-color-accent);
            color: #000;
        }

        .btn-primary:active {
            box-shadow: 0 0 8px var(--glow-color-accent);
}

.btn-danger {
    background-color: var(--danger-color);
            border-color: var(--danger-color);
            color: #fff;
}

.btn-danger:hover {
    background-color: var(--danger-hover);
            border-color: var(--danger-hover);
            box-shadow: 0 0 10px var(--glow-color-danger);
        }

        .btn-danger:active {
            box-shadow: 0 0 5px var(--glow-color-danger);
}

.btn-upgrade {
    background-color: var(--success-color);
            border-color: var(--success-color);
            color: var(--container-bg);
            font-weight: bold;
}

.btn-upgrade:hover {
            background-color: var(--success-hover);
            border-color: var(--success-hover);
            box-shadow: 0 0 10px var(--glow-color-success);
            color: #000;
        }

        .btn-upgrade:active {
            box-shadow: 0 0 5px var(--glow-color-success);
}

.btn-case {
            background: linear-gradient(45deg, #3a4a60, #576879);
            border-color: #7a8aa0;
    font-size: 0.9rem;
            padding: 10px 18px;
}

.btn-case:hover {
            background: linear-gradient(45deg, #4a5a70, #677889);
            border-color: var(--accent-color);
            box-shadow: 0 0 8px var(--glow-color-accent);
}

.btn-full-width {
            width: calc(100% - 16px);
            /* Account for margin */
            margin: 10px 8px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.8rem;
            margin: 2px 4px;
}

/* --- Game Header --- */
.game-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px 25px;
    border-radius: var(--border-radius);
            margin-bottom: 25px;
            border: 1px solid var(--container-border);
}

.game-header h1 {
            margin: 0;
    font-size: 1.8rem;
            flex-grow: 1;
            /* Allows h1 to take available space */
    text-align: left;
            /* Align header text left */
        }

        .user-info {
            display: flex;
            gap: 20px;
            margin: 0 20px;
            /* Space between user info and buttons */
            font-size: 0.9rem;
            color: var(--text-secondary);
            white-space: nowrap;
            /* Prevent wrapping */
}

.user-info p {
            margin: 0;
}

.user-info span {
    font-weight: bold;
    color: var(--accent-color);
            margin-left: 5px;
}

.header-actions {
            display: flex;
            /* Align buttons horizontally */
            gap: 10px;
            /* Space between buttons */
        }

        .header-actions button {
            margin: 0;
            /* Remove default button margin */
            font-size: 0.9rem;
            padding: 8px 15px;
}

/* --- Tab Navigation --- */
.tab-nav {
    text-align: center;
            margin-bottom: 25px;
            background: transparent;
            padding: 0;
    border-radius: var(--border-radius);
            border: 1px solid var(--container-border);
            border-bottom: none;
            display: flex;
            overflow-x: auto;
            /* Enable horizontal scrolling on small screens */
    white-space: nowrap;
            /* Prevent wrapping */
            -webkit-overflow-scrolling: touch;
            /* Smooth scrolling on iOS */
}

.tabButton {
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            border-radius: 0;
            padding: 14px 25px;
            margin: 0;
            color: var(--text-secondary);
            font-family: var(--title-font);
            font-size: 1rem;
            transition: color var(--transition-speed), border-color var(--transition-speed), background-color var(--transition-speed);
            flex: 0 0 auto;
            /* Prevent buttons from shrinking/growing */
            font-weight: 500;
            cursor: pointer;
            outline: none;
        }

        .tabButton:hover {
            color: var(--accent-hover);
            background-color: rgba(0, 191, 255, 0.1);
            transform: none;
            /* Override base button hover */
            box-shadow: none;
            /* Override base button hover */
}

.tabButton.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            background-color: rgba(0, 191, 255, 0.15);
    font-weight: bold;
}

/* --- Tab Content --- */
.tabContent {
    display: none;
            /* Hide all tab content by default */
            background-color: rgba(0, 0, 10, 0.3);
            padding: 25px;
    border-radius: var(--border-radius);
            border: 1px solid var(--container-border);
            margin-bottom: 25px;
    animation: fadeIn 0.5s forwards;
            min-height: 450px;
            /* Ensure minimum height */
}

.tabContent.active {
    display: block;
            /* Show ONLY the active tab content */
}

@keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(15px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
}

/* --- General UI Elements --- */
.resultBox {
    margin-top: 20px;
    padding: 15px;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: var(--border-radius);
    text-align: center;
    font-size: 1rem;
    min-height: 50px;
            border: 1px solid var(--container-border);
            /* Use consistent border */
    opacity: 0;
    transition: opacity 0.5s;
}

.resultBox.visible {
    opacity: 1;
}

.info-box {
    background-color: rgba(255, 255, 255, 0.05);
    padding: 15px;
    border-radius: var(--border-radius);
    margin-bottom: 15px;
            border: 1px solid var(--container-border);
            /* Use consistent border */
}

.info-box p {
    margin-bottom: 5px;
}

        .info-box p:last-child {
            margin-bottom: 0;
}

.cooldown-timer {
    color: var(--accent-color);
    font-weight: bold;
            height: 1.5em;
            /* Prevent layout shift */
    margin-top: 5px;
            text-align: center;
}

.luck-display {
    font-size: 0.95em;
            color: var(--success-color);
            /* Use success color for luck */
    margin-top: 5px;
    font-weight: bold;
}

.filter-section {
    margin-bottom: 20px;
    text-align: center;
    padding: 15px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: var(--border-radius);
            border: 1px solid var(--container-border);
            /* Use consistent border */
}

.filter-section label {
    margin-right: 10px;
}

.filter-section select {
    padding: 10px 15px;
    margin: 0 10px;
            width: auto;
    min-width: 150px;
}

/* --- Lists (Inventory, Deck, etc.) --- */
ul {
    list-style-type: none;
    padding: 0;
}

.card-list,
.data-list {
    max-height: 450px;
    overflow-y: auto;
            border: 1px solid var(--container-border);
            /* Use consistent border */
    border-radius: var(--border-radius);
    padding: 10px;
    background: rgba(0, 0, 0, 0.1);
    margin-top: 10px;
}

.card-list li,
.data-list li {
    margin-bottom: 10px;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.07);
    border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Subtle inner border */
    line-height: 1.5;
    transition: background-color var(--transition-speed);
}

.card-list li:hover {
    background-color: rgba(255, 255, 255, 0.12);
}

.card-list li strong {
    color: var(--accent-color);
    font-weight: bold;
}

.card-list li em {
    color: #ccc;
    font-size: 0.9em;
    display: block;
}

        .card-list .card-actions button {
            /* Target buttons inside card actions */
    margin-top: 8px;
    padding: 5px 10px;
    font-size: 0.85rem;
}

.data-list li {
    background: none;
    border: none;
            border-bottom: 1px dashed var(--container-border);
    padding: 8px 5px;
    margin-bottom: 5px;
}

.data-list li:last-child {
    border-bottom: none;
}

/* --- Scrollbar Styling --- */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: var(--scrollbar-track);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb {
    background: var(--scrollbar-thumb);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--accent-hover);
}

/* --- Card Flip Style --- */
.card-display-area {
            min-height: 220px;
    display: flex;
    justify-content: center;
    align-items: center;
            margin-top: 10px;
}

.card {
    perspective: 1000px;
    width: 90%;
            max-width: 280px;
    min-height: 180px;
    margin: 10px auto;
    position: relative;
}

.card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.7s cubic-bezier(0.4, 0, 0.2, 1);
    transform-style: preserve-3d;
    min-height: inherit;
}

.card.flipped .card-inner {
    transform: rotateY(180deg);
}

.card-front,
.card-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    border: 2px solid var(--card-border);
    border-radius: var(--border-radius);
    background: var(--card-bg);
    padding: 15px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    color: var(--text-color);
    font-size: 0.9rem;
            min-height: inherit;
            /* Ensure front/back take min height */
}

.card-back {
    transform: rotateY(180deg);
    background: var(--card-back-bg);
}

.card-front strong {
    font-size: 1.1em;
            color: inherit;
            /* Color set by JS */
    margin-bottom: 5px;
}

.card-front hr {
    width: 80%;
            border-color: var(--container-border);
            /* Use consistent border */
    margin: 8px 0;
}

.card-back strong {
    color: var(--accent-color);
    margin-bottom: 8px;
}

/* --- START Cases Tab Styles --- */
#caseAnimationWrapper {
    position: relative; /* Needed for absolute positioning of marker */
    width: 100%;
    height: 130px; /* Adjust height as needed */
    background-color: rgba(0, 0, 20, 0.3); /* Darker background for contrast */
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius);
    overflow: hidden; /* CRITICAL: Hides items outside the viewport */
    margin: 20px 0; /* Add some spacing */
    box-sizing: border-box;
}

#caseAnimation {
    display: flex; /* Use flexbox for the scrolling items */
    height: 110px; /* Match item height + padding */
    position: absolute; /* Allows smooth transform animation */
    left: 0; /* Start at the beginning */
    top: 10px; /* Vertical centering */
    will-change: transform; /* Optimize animation performance */
    /* transition is set by JS */
}

#caseAnimation .item {
    flex: 0 0 110px; /* CRITICAL: Fixed width for each item (adjust as needed) */
    height: 110px; /* Match container height */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 10px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background-color: var(--card-bg); /* Use card background */
    color: var(--text-color);
    margin: 0 5px; /* Add spacing between items */
    border-radius: var(--border-radius);
    box-sizing: border-box;
    font-size: 0.9em;
    overflow: hidden; /* Prevent text spillover */
    white-space: normal; /* Allow text wrapping */
}
#caseAnimation .item span { /* Style the name part */
    font-weight: bold;
    display: block; /* Ensure it takes full width */
    margin-bottom: 4px;
}


.case-marker {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%; /* Center horizontally */
    transform: translateX(-50%); /* Fine-tune centering */
    width: 4px; /* Marker width */
    background: linear-gradient(to bottom, transparent, #ffa500, #ff4500, #ffa500, transparent); /* Orange/red gradient */
    box-shadow: 0 0 8px rgba(255, 165, 0, 0.8); /* Orange glow */
    z-index: 10; /* Ensure marker is above items */
    border-radius: 2px;
}

#caseResult { /* Style the result box */
    margin-top: 20px;
    /* other styles from resultBox apply */
}
/* --- END Cases Tab Styles --- */

/* --- Specific Tab Styles --- */

/* Roll Tab */
#rarityList {
    /* Container for odds */
    margin-top: 20px;
}

#rarityRolledList {
    /* The ul itself */
    max-height: 200px;
    /* Limit height */
    overflow-y: auto;
    padding: 10px;
    border: 1px solid var(--container-border);
    border-radius: var(--border-radius);
    background: rgba(0, 0, 0, 0.1);
}

#rarityRolledList li {
    background: none;
    border: none;
    padding: 4px 0;
    margin-bottom: 2px;
    font-size: 0.9em;
    color: #ccc;
}

#rarityRolledList span {
    display: inline-block;
            min-width: 100px;
            /* Align text */
    font-weight: bold;
}

/* Inventory Tab */
#sellDuplicatesBtn {
    margin-bottom: 15px;
}

/* Battle Tab */
#battleResultDiv {
    margin-top: 15px;
}

#turnLogDiv {
    white-space: pre-wrap;
            background: rgba(0, 0, 10, 0.4);
            /* Similar to chat bg */
            color: var(--text-color);
    padding: 15px;
    border-radius: var(--border-radius);
    height: 250px;
    overflow-y: auto;
    margin-top: 15px;
            border: 1px solid var(--input-border);
            /* Use consistent border */
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.9em;
    line-height: 1.4;
}

/* Leaderboard Tab */
#leaderboardList li {
    font-size: 1.1em;
            background: none;
            /* Remove card-list styling */
            border: none;
            border-bottom: 1px dashed var(--container-border);
            padding: 8px 5px;
            margin-bottom: 5px;
        }

        #leaderboardList li:last-child {
            border-bottom: none;
        }

#leaderboardList li.current-user {
    font-weight: bold;
    color: var(--accent-color);
            background-color: rgba(0, 229, 255, 0.1);
            /* Use accent glow color */
            border-radius: var(--border-radius);
            /* Add radius for highlight */
}

/* Bank Tab */
.bank-section {
    background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--container-border);
            /* Use consistent border */
    border-radius: var(--border-radius);
    padding: 20px;
    margin-bottom: 20px;
}

.bank-section h3 {
    margin-top: 0;
    color: var(--accent-color);
            border-bottom: 1px solid var(--container-border);
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.bank-section p {
    margin: 5px 0 12px;
}

.bank-action {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 10px;
            flex-wrap: wrap;
            /* Allow wrapping on small screens */
}

.bank-action input[type="number"] {
    flex-grow: 1;
    width: auto;
            /* Allow shrinking */
            min-width: 100px;
            /* Prevent becoming too small */
    margin: 0;
}

.bank-action button {
    flex-shrink: 0;
    margin: 0;
}

        /* Chat Tab */
        /* Note: Chat elements were moved INTO the chat tab section */
        #chatContent {
            display: flex;
            /* Use flexbox for layout */
            flex-direction: column;
            /* min-height is already set on .tabContent */
        }

        #chatMessages {
            flex-grow: 1;
            /* Take available vertical space */
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(0, 0, 10, 0.4);
            border-radius: var(--border-radius);
            border: 1px solid var(--input-border);
        }

        #chatMessages p {
            /* Style individual messages */
            margin-bottom: 8px;
            word-wrap: break-word;
            /* Prevent long words overflowing */
            line-height: 1.4;
        }

        #chatMessages p:last-child {
            margin-bottom: 0;
        }

        #chatMessages .username {
            color: var(--accent-color);
            font-weight: bold;
            margin-right: 5px;
        }

        #chatMessages .timestamp {
            font-size: 0.8em;
            color: var(--text-secondary);
            margin-left: 10px;
            float: right;
            /* Align timestamp right */
        }

        #chatInputContainer {
            display: flex;
            gap: 10px;
            align-items: center;
            /* Align input and button vertically */
        }

        #chatInputContainer input[type="text"] {
            flex-grow: 1;
            /* Input takes available horizontal space */
            margin: 0;
            /* Remove default margins */
        }

        #chatInputContainer button {
            margin: 0;
            /* Remove default margins */
            flex-shrink: 0;
            /* Prevent button shrinking */
        }

        /* Black Market Tab */
        .market-section {
            /* Generic class for market sections */
            padding: 20px;
            background: rgba(106, 13, 173, 0.1);
            /* Purple tint */
            border: 1px solid var(--secondary-hover);
            /* Use purple border */
            border-radius: var(--border-radius);
            margin-bottom: 20px;
        }

        .market-section h3 {
            color: var(--secondary-hover);
            /* Purple heading */
            margin-top: 0;
            border-bottom: 1px solid var(--secondary-hover);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .market-section .data-list li span {
            font-weight: bold;
            color: var(--accent-color);
            /* Highlight counts */
}

.market-section p {
    margin-top: 10px;
}

.market-section hr {
    margin-top: 10px;
    margin-bottom: 10px;
}

.bm-code-hint {
    font-size: 0.8em;
    margin-top: 5px;
}

/* --- Footer --- */
.game-footer {
    text-align: center;
    margin-top: 30px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: var(--border-radius);
    font-size: 0.9em;
    color: #bbb;
}

/* --- Overlays and Popups --- */
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--overlay-bg);
            display: none;
            /* Managed by JS */
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity var(--transition-speed) ease-in-out;
}

.overlay.active {
    display: flex;
    opacity: 1;
}

.overlay-circle {
    width: 10px;
    height: 10px;
    background-color: white;
    border-radius: 50%;
    position: absolute;
    transform: scale(0);
    transition: transform 1.5s cubic-bezier(0.25, 1, 0.5, 1);
}

.overlay.active .overlay-circle {
            transform: scale(200);
            /* Adjust scale factor as needed */
}

.popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.9);
    width: 90%;
    max-width: 450px;
    background: var(--popup-bg);
    border: 1px solid var(--accent-color);
    border-radius: var(--border-radius);
    padding: 25px;
    box-shadow: var(--box-shadow);
    z-index: 1001;
            display: none;
            /* Managed by JS */
    text-align: center;
    color: var(--text-color);
    opacity: 0;
    transition: opacity var(--transition-speed) ease-in-out, transform var(--transition-speed) ease-in-out;
}

.popup.active {
    display: block;
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

.popup h3 {
    color: var(--accent-color);
    margin-top: 0;
    margin-bottom: 15px;
}

.popup p {
    margin-bottom: 10px;
    line-height: 1.6;
}

.popup p strong {
    color: var(--accent-color);
}

.popup button {
    margin-top: 20px;
}

/* --- Computer UI Specific Styles --- */
body.computer-ui .container {
    max-width: 1200px;
}

body.computer-ui .tab-nav {
            white-space: normal;
            /* Allow wrapping */
            flex-wrap: wrap;
            /* Allow wrapping */
}

body.computer-ui .tabButton {
    padding: 12px 25px;
    font-size: 1.05rem;
            flex-grow: 1;
            /* Allow buttons to grow on larger screens */
}

body.computer-ui .game-header {
    padding: 20px 30px;
}

body.computer-ui .potion-item {
    flex-wrap: nowrap;
            /* Prevent wrapping on larger screens */
}

body.computer-ui .potion-item p {
    flex-basis: auto;
    margin-bottom: 0;
}

body.computer-ui .bank-section {
    padding: 25px;
}

body.computer-ui .bank-action {
    flex-wrap: nowrap;
            /* Prevent wrapping */
}

/* --- Responsive Adjustments --- */
        @media (max-width: 992px) {

            /* Adjust breakpoint */
    .game-header {
        flex-direction: column;
                align-items: stretch;
                /* Stretch items */
                gap: 10px;
            }

            .game-header h1 {
                text-align: center;
                /* Center title on smaller screens */
            }

            .user-info {
                justify-content: center;
                /* Center user info */
                margin: 0;
            }

    .header-actions {
                justify-content: center;
                /* Center header buttons */
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

    .tabButton {
                padding: 10px 15px;
        font-size: 0.9rem;
    }

    .deck-layout {
        flex-direction: column;
    }

    .deck-section {
        min-width: unset;
    }

    .bank-action input[type="number"] {
                min-width: 80px;
    }

            /* Further shrink input */
    .potion-item {
        justify-content: flex-start;
    }

    .popup {
        width: 95%;
    }
}

@media (max-width: 480px) {
            h1 {
                font-size: 1.8rem;
            }

            /* Slightly larger H1 */
            h2 {
                font-size: 1.5rem;
            }

            h3 {
                font-size: 1.3rem;
            }

            button,
            .btn {
        padding: 10px 15px;
        font-size: 0.9rem;
    }

    input[type="text"],
    input[type="password"],
    input[type="number"],
            input[type="email"],
    select {
        padding: 10px 12px;
        font-size: 0.95rem;
    }

    .card {
        max-width: 240px;
        min-height: 160px;
    }

            .card-front,
            .card-back {
        font-size: 0.85rem;
        padding: 10px;
    }

    #caseAnimation .item {
        flex: 0 0 90px;
        height: 90px;
        font-size: 12px;
    }

    #caseAnimationWrapper {
        height: 110px;
    }

    #caseAnimation {
        height: 90px;
    }

            .bank-action {
                flex-direction: column;
                align-items: stretch;
            }

            /* Stack bank actions */
            .bank-action input[type="number"] {
                width: 100%;
            }

            .bank-action button {
                width: 100%;
                margin-top: 5px;
            }

            #chatInputContainer {
                flex-direction: column;
                align-items: stretch;
            }

            #chatInputContainer button {
                margin-top: 5px;
            }
        }

        /* --- Admin Panel Styles --- */
        /* Align button groups */
        #adminGeneratorSection {
            max-height: 60vh; /* Limit height to 60% of viewport height */
            overflow-y: auto; /* Add vertical scrollbar if needed */
            padding: 10px; /* Add some padding inside the scrollable area */
            border: 1px solid var(--input-border); /* Optional: Add border */
            border-radius: var(--border-radius);
            margin-top: 10px; /* Add some space above */
        }

        #adminGeneratorSection .button-group {
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        #adminGeneratorSection h4 {
            margin-top: 15px;
            margin-bottom: 5px;
            color: var(--accent-color);
            font-family: var(--primary-font);
            font-size: 1.1rem;
            text-align: left;
        }

        #adminGeneratorSection .button-group button {
            font-size: 0.85rem;
            padding: 5px 10px;
        }

        #adminSelectionInfo {
            margin-top: 15px;
            font-weight: bold;
            color: var(--accent-hover);
        }

        #adminCodeOutput {
            margin-top: 15px;
            padding: 10px;
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: var(--border-radius);
            word-wrap: break-word;
        }

        /* --- Redemption Tab Styles --- */
        #redemptionPasswordPrompt,
        #redemptionInterface,
        #reversalCodePrompt {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #redemptionPasswordPrompt button,
        #redemptionInterface button,
        #reversalCodePrompt button {
            width: auto;
            /* Don't force full width */
            align-self: flex-start;
            /* Align button left */
        }

        #redemptionStatus {
            margin-top: 10px;
        }

        #redemptionCooldown,
        #redemptionLockout {
            margin-top: 5px;
        }

/* Redemption Tab */
.redemption-lockout-text {
    color: var(--danger-color);
}
#redemptionInputGroup {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 10px;
}
.redemption-button {
    align-self: flex-start;
}
.reversal-prompt {
    margin-top: 15px;
}
.reversal-prompt-text {
    color: var(--danger-color);
}

/* --- Admin Panel Styles --- */
#adminCloseBtn {
    margin-top: 15px;
}

/* --- Responsive adjustments for Case Animation --- */
@media (max-width: 480px) {
     #caseAnimationWrapper {
         height: 110px; /* Adjust height */
     }
     #caseAnimation {
         height: 90px; /* Match item height */
         top: 10px; /* Re-center */
     }
    #caseAnimation .item {
        flex: 0 0 90px; /* Smaller items on small screens */
        height: 90px;
        font-size: 0.8em;
        padding: 5px;
        margin: 0 3px; /* Adjust spacing */
    }
    #caseAnimation .item span {
        font-size: 0.9em; /* Adjust font size */
    }

}

/* --- Ability Effect Animations --- */
@keyframes heal-pulse {
    0% { box-shadow: 0 0 5px 2px rgba(76, 175, 80, 0.7); }
    50% { box-shadow: 0 0 15px 5px rgba(76, 175, 80, 1); }
    100% { box-shadow: 0 0 5px 2px rgba(76, 175, 80, 0.7); }
}

.ability-heal-effect {
    animation: heal-pulse 0.8s ease-out 1;
}

@keyframes damage-boost-flash {
    0%, 100% { box-shadow: 0 0 4px 1px rgba(255, 87, 34, 0.6); }
    50% { box-shadow: 0 0 12px 4px rgba(255, 87, 34, 1); }
}

.ability-damage-boost-effect {
    animation: damage-boost-flash 0.6s ease-in-out 1;
}

@keyframes defense-buff-shield {
    0% { box-shadow: 0 0 5px 2px rgba(33, 150, 243, 0.7); border: 2px solid rgba(33, 150, 243, 0.5); }
    50% { box-shadow: 0 0 15px 5px rgba(33, 150, 243, 1); border: 2px solid rgba(33, 150, 243, 0.9); }
    100% { box-shadow: 0 0 5px 2px rgba(33, 150, 243, 0.7); border: 2px solid rgba(33, 150, 243, 0.5); }
}

.ability-defense-buff-effect {
    animation: defense-buff-shield 1s ease-out 1;
}

/* Ensure card positioning allows effects to show */
.battle-area .card {
    position: relative; /* Needed for absolute positioned children like popups */
    z-index: 1; /* Base stacking context */
}

/* --- Battle Animations --- */
.battle-card {
    transition: transform 0.5s ease-in-out, opacity 0.3s ease;
}

@keyframes cardKnockPlayer {
    0% { transform: translate(0, 0) rotate(0); }
    25% { transform: translate(-20px, -10px) rotate(-5deg); }
    50% { transform: translate(20px, 10px) rotate(5deg); }
    75% { transform: translate(-10px, 5px) rotate(-2deg); }
    100% { transform: translate(0, 0) rotate(0); }
}

@keyframes cardKnockOpponent {
    0% { transform: translate(0, 0) rotate(0); }
    25% { transform: translate(20px, 10px) rotate(5deg); }
    50% { transform: translate(-20px, -10px) rotate(-5deg); }
    75% { transform: translate(10px, -5px) rotate(2deg); }
    100% { transform: translate(0, 0) rotate(0); }
}

.battle-card.attacking-player {
    animation: cardKnockPlayer 0.6s ease-out;
    z-index: 10; /* Bring attacker slightly forward */
}

.battle-card.attacking-opponent {
    animation: cardKnockOpponent 0.6s ease-out;
    z-index: 10; /* Bring attacker slightly forward */
}

@keyframes hitEffect {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.05); filter: brightness(1.5) saturate(1.5); }
    100% { opacity: 1; transform: scale(1); filter: brightness(1) saturate(1); }
}

.battle-card.hit {
    animation: hitEffect 0.3s ease-in-out;
}

@keyframes fadeOutDefeated {
    0% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(20px); }
}

.battle-card.defeated {
    animation: fadeOutDefeated 0.5s ease-in forwards;
    pointer-events: none;
}

.stat-change-popup {
    position: absolute;
    top: -20px; /* Position above the card */
    left: 50%;
    transform: translateX(-50%);
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 0.9em;
    font-weight: bold;
    color: white;
    z-index: 20;
    opacity: 0;
    transition: opacity 0.3s ease-out, top 0.3s ease-out;
    white-space: nowrap;
}

.stat-change-popup.buff {
    background-color: rgba(0, 200, 0, 0.8);
    text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
}

.stat-change-popup.debuff {
    background-color: rgba(200, 0, 0, 0.8);
    text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
}

.stat-change-popup.show {
    opacity: 1;
    top: -30px; /* Move slightly upwards */
}

    </style>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Orbitron:wght@500;700&display=swap"
        rel="stylesheet">

    <!-- Firebase SDKs (using compat for potential legacy code in script.js) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-functions-compat.js"></script>
    <!-- Add other SDKs like database, storage, functions if needed -->

</head>

<body>
    <div class="container">
        <div class="ui-toggle">
            <button id="toggleUI" class="btn">Switch to Computer UI</button>
        </div>

        <!-- Login/Signup Screen -->
        <section id="loginScreen" class="screen active">
            <h2>Login / Sign Up</h2>
            <form id="loginForm">
                <input type="email" id="emailInput" placeholder="Email" required autocomplete="email">
                <input type="password" id="passwordInput" placeholder="Password" required
                    autocomplete="current-password">
                <input type="text" id="displayNameInput" placeholder="Display Name (Sign Up Only)"
                    autocomplete="username" class="hidden">
                <div class="login-actions">
                    <label><input type="radio" name="action" value="login" checked> Login</label>
                    <label><input type="radio" name="action" value="signup"> Sign Up</label>
                </div>
                <button type="submit" class="btn-primary btn-full-width">Submit</button>
            </form>
        </section>

        <!-- Main Game Screen (Initially hidden) -->
        <section id="gameScreen" class="screen">
            <header class="game-header">
                <h1>Rarity Roll Game</h1>
                <div class="user-info">
                    <p id="userGreeting">Welcome, User</p>
                    <p id="totalPowerDisplay">Total Power: <span>0</span></p>
                    <p id="currencyDisplay">Coins: <span>0</span></p> <!-- Start at 0, loaded from DB -->
                </div>
                <div class="header-actions">
                    <button id="profileBtn" class="btn btn-secondary">Profile</button>
                    <button id="logoutBtn" class="btn btn-secondary">Logout</button>
                    <button id="deleteDataBtn" class="btn btn-danger">Delete Data</button>
                </div>
            </header>

            <nav class="tab-nav">
                <button data-tab="roll" class="tabButton active">Roll</button>
                <button data-tab="deck" class="tabButton">Deck</button>
                <button data-tab="inventory" class="tabButton">Inventory</button>
                <button data-tab="appraisal" class="tabButton">Appraisal</button>
                <button data-tab="upgrades" class="tabButton">Upgrades/Potions</button>
                <button data-tab="cases" class="tabButton">Cases</button>
                <button data-tab="battle" class="tabButton">Battle</button>
                <button data-tab="leaderboard" class="tabButton">Leaderboard</button>
                <button data-tab="daily" class="tabButton">Daily</button> <!-- Shortened Name -->
                <button data-tab="bank" class="tabButton">Bank</button>
                <button data-tab="chat" class="tabButton">Chat</button>
                <button data-tab="blackMarket" class="tabButton">Black Market</button> <!-- Renamed -->
                <button data-tab="redemption" class="tabButton">Redeem</button> <!-- Shortened Name -->
            </nav>

            <main class="main-content">
                <!-- Common Filters (Initially hidden) -->
                <div id="inventoryFilters" class="filter-section hidden">
                    <h3>Filter Inventory</h3>
                    <label for="rarityFilter">Rarity:</label>
                    <select id="rarityFilter">
                        <option value="">All</option>
                        <!-- Options populated by JS -->
                    </select>
                </div>
                 <div id="deckFilters" class="filter-section hidden">
                     <h3>Filter Available Cards</h3>
                     <label for="deckRarityFilter">Rarity:</label>
                     <select id="deckRarityFilter">
                         <option value="">All Rarities</option>
                         <!-- Options populated by JS -->
                     </select>
                 </div>

                <!-- Roll Tab -->
                <section id="rollContent" class="tabContent active">
                    <h2>Roll for Cards</h2>
                    <div id="rollInstructions" class="info-box">
                        <p>Click "Roll for Card" to get a new card.</p>
                        <p id="boostStatus"></p>
                        <p class="luck-display" id="rollLuckDisplay">Current Luck Bonus: +0%</p>
                    </div>
                    <button id="rollButton" class="btn btn-primary btn-full-width">Roll for Card</button>
                    <p id="cooldownTimer" class="cooldown-timer"></p>
                    <div id="rollResult" class="resultBox card-display-area">
                        <!-- Card displayed here -->
                    </div>
                    <button id="flipCardBtn" class="btn btn-secondary hidden">Flip
                        Card</button>
                    <div id="rarityList" class="info-box">
                        <h3>Rarity Odds</h3>
                        <ul id="rarityRolledList">
                            <!-- Populated by JS -->
                        </ul>
                    </div>
                </section>

                <!-- Deck Builder Tab -->
                <section id="deckContent" class="tabContent">
                    <h2>Deck Builder</h2>
                    <p class="info-box">Select up to 5 cards from your inventory for your battle deck.</p>
                    <!-- Deck Filters shown via JS -->
                    <div class="deck-layout">
                        <div id="deckBuilder" class="deck-section">
                            <h3>Available Cards (Inventory)</h3>
                            <ul id="deckInventoryList" class="card-list"></ul>
                        </div>
                        <div id="currentDeck" class="deck-section">
                            <h3>Your Deck (<span id="deckCount">0</span>/5) - Power: <span id="deckPower">0</span></h3>
                            <ul id="deckList" class="card-list"></ul>
                        </div>
                    </div>
                </section>

                <!-- Inventory Tab -->
                <section id="inventoryContent" class="tabContent">
                    <h2>Your Inventory (<span id="inventoryCount">0</span>)</h2>
                    <!-- Inventory Filters shown via JS -->
                    <button id="sellDuplicatesBtn" class="btn btn-secondary">Sell
                        Common/Uncommon Duplicates</button>
                    <ul id="inventoryList" class="card-list"></ul>
                </section>

                <!-- Appraisal Tab -->
                <section id="appraisalContent" class="tabContent">
                    <h2>Appraisal</h2>
                    <p class="info-box">Select a card to appraise. Cost: 500 coins. Increases value by 50% and might
                        improve grade/quality.</p>
                    <ul id="appraisalList" class="card-list"></ul>
                </section>

                <!-- Upgrades / Potions Tab -->
                <section id="upgradesContent" class="tabContent">
                    <h2>Upgrades and Potions</h2>
                    <div class="upgrade-section">
                        <h3>Core Upgrades</h3>
                        <p id="cooldownLevelDisplay">Cooldown Upgrade Level: 0</p>
                        <p id="luckLevelDisplay">Luck Level: 0</p>
                        <p id="currentCooldownDisplay">Current Roll Cooldown: 5.0s</p>
                        <p class="luck-display" id="upgradeLuckDisplay">Current Luck Bonus: +0%</p>
                        <button id="upgradeCooldownBtn" class="btn btn-upgrade">Upgrade Roll Speed (Cost: <span
                                id="cooldownCost">50</span>)</button>
                        <button id="upgradeLuckBtn" class="btn btn-upgrade">Upgrade Luck (Cost: <span
                                id="luckCost">100</span>)</button>
                    </div>
                    <hr>
                    <div class="potion-section">
                        <h3>Potions</h3>
                        <div id="potionStatus" class="info-box"></div>
                        <div class="potion-item">
                            <p>Luck Potions: <span id="luckPotionCount">0</span></p>
                            <button id="buyLuckPotionBtn" class="btn btn-secondary">Buy (100)</button>
                            <button id="useLuckPotionBtn" class="btn btn-secondary">Use (30s)</button>
                        </div>
                        <div class="potion-item">
                            <p>Speed Potions: <span id="speedPotionCount">0</span></p>
                            <button id="buySpeedPotionBtn" class="btn btn-secondary">Buy (120)</button>
                            <button id="useSpeedPotionBtn" class="btn btn-secondary">Use (30s)</button>
                        </div>
                        <div class="potion-item">
                            <p>Battle Potions: <span id="battlePotionCount">0</span></p>
                            <button id="buyBattlePotionBtn" class="btn btn-secondary">Buy (150)</button>
                            <button id="useBattlePotionBtn" class="btn btn-secondary">Use (Next Battle)</button>
                        </div>
                    </div>
                </section>

                <!-- Cases Tab -->
                <section id="casesContent" class="tabContent">
                    <h2>Cases</h2>
                    <p class="info-box">Open cases for a chance at cards and potions.</p>
                    <div id="caseAnimationWrapper">
                         <div id="caseAnimation"></div>
                         <div class="case-marker"></div>
                    </div>
                    <div id="caseResult" class="resultBox"></div>
                    <div id="caseButtonsContainer" class="case-buttons">
                        <!-- Case buttons added by JS -->
                    </div>
                </section>

                <!-- Battle Tab -->
                <section id="battleContent" class="tabContent">
                    <h2>Battle Arena</h2>
                    <p class="info-box">Use your deck against an AI opponent. Build your deck first!</p>
                    <button id="startBattleBtn" class="btn btn-primary">Start Battle</button>
                    <div id="battleArea" class="hidden">
                        <h3>Battle Log</h3>
                        <div id="turnLogDiv"></div> <!-- No .log-box needed -->
                        <button id="nextTurnBtn" class="btn btn-secondary hidden">Next Turn</button>
                        <div id="battleResultDiv" class="resultBox"></div>
                    </div>
                </section>

                <!-- Leaderboard Tab -->
                <section id="leaderboardContent" class="tabContent">
                    <h2>Leaderboard</h2>
                    <p id="playerScoreDisplayP" class="info-box">Your Score: 0</p> <!-- Added P suffix for consistency -->
                    <ul id="leaderboardListUl" class="data-list"></ul> <!-- Added Ul suffix for consistency -->
                </section>

                <!-- Daily Challenges Tab -->
                <section id="dailyContent" class="tabContent">
                    <h2>Daily Challenges</h2>
                    <div id="dailyChallengeInfo" class="info-box"></div>
                    <button id="claimDailyChallengeBtn" class="btn btn-primary hidden">Claim Reward</button>
                    <button id="generateNewChallengeBtn" class="btn btn-secondary">New Challenge (Reset Progress)</button>
                </section>

                <!-- Bank Tab -->
                <section id="bankContent" class="tabContent">
                    <h2>Bank</h2>
                    <div class="bank-section">
                        <h3>Passive Income</h3>
                        <p>Earn coins based on your Total Power every 5 hours.</p>
                        <p id="passiveIncomeRate">Rate: 0 Coins / 5 hours</p>
                        <p id="nextPassiveIncomeTime">Next Payout: Calculating...</p>
                    </div>
                    <div class="bank-section">
                        <h3>Savings Account</h3>
                        <p>Earn 2% interest every 8 hours on your deposited amount.</p>
                        <p id="savingsBalance">Balance: 0 Coins</p>
                        <p id="nextSavingsInterestTime">Next Interest: Calculating...</p>
                        <div class="bank-action">
                            <input type="number" id="depositAmount" placeholder="Amount" min="1">
                            <button id="depositBtn" class="btn btn-secondary">Deposit</button>
                        </div>
                        <button id="withdrawBtn" class="btn btn-secondary">Withdraw All</button>
                    </div>
                    <div class="bank-section">
                        <h3>Loans</h3>
                        <p>Take out a loan (up to 15,000 Coins). Interest: 5% daily.</p>
                        <p id="loanAmountDisplay">Current Loan: 0 Coins</p>
                        <p id="nextLoanInterestTime">Next Interest Added: Calculating...</p>
                        <div class="bank-action">
                            <input type="number" id="loanRequestAmount" placeholder="Amount" min="1" max="15000">
                            <button id="takeLoanBtn" class="btn btn-secondary">Take Loan</button>
                        </div>
                        <div class="bank-action">
                            <input type="number" id="repayLoanAmount" placeholder="Amount" min="1">
                            <button id="repayLoanBtn" class="btn btn-secondary">Repay Loan</button>
                        </div>
                    </div>
                </section>

                <!-- Chat Tab -->
                <section id="chatContent" class="tabContent">
                    <h2>Global Chat</h2>
                    <div id="chatMessages">
                        <p>Loading chat...</p>
                    </div>
                    <div id="chatInputContainer">
                        <input type="text" id="chatInput" placeholder="Enter message..." maxlength="150" disabled>
                        <button id="sendChatBtn" class="btn btn-primary" disabled>Send</button>
                    </div>
                </section>

                <!-- Black Market Tab -->
                <section id="blackMarketContent" class="tabContent">
                    <h2>Black Market</h2>
                    <p class="info-box">A shady place for exclusive goods. Access requires payment and passwords.</p>
                    <div class="market-section">
                        <h3>Actions</h3>
                        <button id="buyMarketTicketBtn" class="btn btn-primary">Buy Ticket (30000)</button>
                        <!-- <p>Purchase Password: [purchase1]</p> -->
                        <hr>
                        <button id="useMarketTicketBtn" class="btn btn-secondary">Use Ticket (Get Ultra Token)</button>
                        <button id="useUltraTokenBtn" class="btn btn-secondary">Use Ultra Token</button>
                        <div id="consumableButtonsContainer"></div>
                        <!-- <p>Usage Password: [Blackmarket item42O]</p> -->
                        <!-- <p class="bm-code-hint">
                            (Using code-generated items requires password: [Codeitems69])</p> -->
                     </div>
                    <div class="market-section">
                        <h3>Your Items</h3>
                          <ul id="marketItemList" class="data-list">
                              <li>Black Market Tickets: <span id="marketTicketCount">0</span></li>
                              <li>Ultra Tokens: <span id="ultraTokenCount">0</span></li>
                            <li>Exclusive Cases: <span id="exclusiveCaseCount">0</span> <button id="useExclusiveCaseBtn"
                                    class="btn btn-secondary btn-small hidden">Use</button></li>
                            <li>Exclusive Luck Potions: <span id="exclusiveLuckPotionCount">0</span> <button
                                    id="useExclusiveLuckPotionBtn"
                                    class="btn btn-secondary btn-small hidden">Use</button></li>
                            <li>Ultra Lucky Rolls: <span id="ultraLuckyRollCount">0</span> <button
                                    id="useUltraLuckyRollBtn" class="btn btn-secondary btn-small hidden">Use</button>
                            </li>
                            <!-- Other code items might appear here if redeemed -->
                          </ul>
                     </div>
                </section>

                <!-- Redemption Tab -->
                <section id="redemptionContent" class="tabContent">
                    <h2>Code Redemption</h2>
                    <div id="redemptionPasswordPrompt" class="info-box">
                        <p>Enter access password to redeem codes.</p>
                        <input type="password" id="redemptionPasswordInput" placeholder="Redemption Access Code">
                        <button id="redemptionUnlockBtn" class="btn btn-secondary">Unlock</button>
                    </div>
                    <div id="redemptionInterface" class="hidden">
                        <p id="redemptionStatus" class="info-box">Enter a code to redeem. Attempts are limited.</p>
                        <p id="redemptionCooldown" class="cooldown-timer"></p>
                        <p id="redemptionLockout" class="cooldown-timer redemption-lockout-text"></p>
                        <div id="redemptionInputGroup">
                            <input type="text" id="redemptionCodeInput" placeholder="Enter Code">
                            <button id="redeemCodeBtn" class="btn btn-primary redemption-button">Redeem</button>
                        </div>
                         <div id="reversalCodePrompt" class="hidden reversal-prompt">
                            <p class="reversal-prompt-text">
                                Invalid code. Enter reversal code to avoid lockout:</p>
                              <input type="password" id="reversalCodeInput" placeholder="Reversal Code">
                            <button id="submitReversalBtn" class="btn btn-secondary">Submit Reversal</button>
                         </div>
                    </div>
                </section>

            </main>

            <footer class="game-footer">
                <p>
                    Roll cards, build decks, manage inventory, open cases, upgrade stats, battle opponents, climb the
                    ranks, complete challenges, and manage your finances!
                </p>
            </footer>
        </section> <!-- End Game Screen -->

    </div> <!-- End Container -->

   <!-- Appraisal Animation Elements -->
<div id="appraisalOverlay" class="overlay">
    <div id="appraisalCircle" class="overlay-circle"></div>
</div>
<div id="appraisalPopup" class="popup">
    <h3>Appraisal Results</h3>
    <div id="appraisalPopupMessage"></div>
    <button id="closeAppraisalPopupBtn" class="btn btn-secondary">OK</button> <!-- Corrected closing tag -->
</div>

    <!-- Profile Edit Modal (New) -->
    <div id="profileModal" class="popup">
        <h3>Edit Profile</h3>
        <p>You can change your display name once every 7 days.</p>
        <div class="profile-edit-section">
            <label for="newNameInput">New Display Name:</label>
            <input type="text" id="newNameInput" placeholder="Enter new name" maxlength="25">
            <p id="profileStatusMsg" class="info-box" style="margin-top: 10px;">Status: Loading...</p>
            <button id="saveNameBtn" class="btn btn-primary">Save Name</button>
        </div>
        <button id="closeProfileBtn" class="btn btn-secondary">Close</button>
    </div>

    <!-- Admin Code Generator Panel (Hidden Popup) -->
    <div id="adminPanel" class="popup">
         <h3>Admin Code Generator</h3>
         <div id="adminPasswordSection">
             <p>Enter Admin Password:</p>
             <input type="password" id="adminPasswordInput" placeholder="Admin Password">
            <button id="adminLoginBtn" class="btn btn-primary">Login</button>
         </div>
         <div id="adminGeneratorSection" class="hidden">
              <h4>Currency</h4>
              <div class="button-group" id="adminCurrencyButtons">
                  <button data-type="currency" data-value="100">100 Coins</button>
                  <button data-type="currency" data-value="1000">1000 Coins</button>
                  <button data-type="currency" data-value="10000">10000 Coins</button>
              </div>
              <h4>Standard Cases</h4>
              <div class="button-group" id="adminCaseButtons">
                  <!-- Buttons populated by JS -->
              </div>
               <h4>Standard Potions</h4>
              <div class="button-group" id="adminPotionButtons">
                  <!-- Buttons populated by JS -->
              </div>
              <h4>Specific Rarity Card</h4>
               <div class="button-group" id="adminRarityButtons">
                 <!-- Buttons populated by JS -->
               </div>
               <h4>Black Market Items</h4>
                <div class="button-group" id="adminBlackMarketButtons">
                     <button data-type="consumable" data-value="black_market_ticket">BM Ticket</button>
                     <button data-type="consumable" data-value="ultra_token">Ultra Token</button>
                     <button data-type="consumable" data-value="exclusive_case">Exclusive Case</button>
                     <button data-type="consumable" data-value="exclusive_luck_potion">Exclusive Luck Potion</button>
                     <button data-type="consumable" data-value="ultra_lucky_roll">Ultra Lucky Roll</button>
                </div>

            <!-- Added Expiration Date Input -->
            <div class="admin-option">
                <label for="adminExpiryDateInput">Expiration Date (Optional):</label>
                <input type="date" id="adminExpiryDateInput">
            </div>

            <div id="adminSelectionInfo">Selected: None</div>
            <button id="adminGenerateCodeBtn" class="btn btn-primary btn-full-width" disabled>Generate Code</button>
              <div id="adminCodeOutput"></div>
            <button id="adminCloseBtn" class="btn btn-secondary">Close Panel</button>
         </div>
    </div>

    <!-- Link to external JS -->
    <script>
        //*** REFACTORED JAVASCRIPT START ***
// --- Firebase Configuration ---
// IMPORTANT: Replace with your actual Firebase config object
const firebaseConfig = {
    apiKey: "AIzaSyAEq6kMTzdMzgcu3_Lr2booOy103jqVivU",
    authDomain: "cardsofrng.firebaseapp.com",
    databaseURL: "https://cardsofrng-default-rtdb.firebaseio.com",
    projectId: "cardsofrng",
    storageBucket: "cardsofrng.firebasestorage.app",
    messagingSenderId: "280031005647",
    appId: "1:280031005647:web:f11663afea86ee54bea0ba",
    measurementId: "G-YMX3ZJSX7T"
};

// --- Application State & Constants ---
const AppState = {
    // Firebase Services (initialized later)
    auth: null,
    db: null,

    // User State
    currentUser: null,
    currentUserId: null,
    userData: {}, // Local cache of Firestore user data

    // Listeners (to unsubscribe on logout)
    unsubscribeUserData: null,
    unsubscribeLeaderboard: null,
    unsubscribeChat: null,

    // Game State
    isComputerUI: false,
    isRolling: false,
    rollCooldownTimer: null,
    activeBoosts: { // Centralized boost management
        luck: { active: false, timer: null, remaining: 0 },
        speed: { active: false, timer: null, remaining: 0 },
        battle: { active: false }, // Battle boost is consumed, not timed
        exclusiveLuck: { active: false, timer: null, remaining: 0 },
    },
    currentBattleState: null,
    activeTab: 'roll',
    redemptionUnlocked: false,
    globalCardIdCounter: 0, // TODO: Consider moving to Firestore for true persistence/uniqueness

    // Admin State
    adminPanel: {
        isVisible: false,
        isLoggedIn: false,
        selectedItems: [] // Changed from selectedItem: null
    }
};

const Constants = Object.freeze({
    // Durations & Costs
    BASE_COOLDOWN_MS: 5000,
    COOLDOWN_REDUCTION_MS: 250,
    MIN_COOLDOWN_MS: 1000,
    BOOST_DURATION_MS: 30000, // 30 seconds
    APPRAISAL_COST: 500,
    APPRAISAL_VALUE_MULTIPLIER: 1.5,
    GRADE_UPGRADE_CHANCE: 0.5,
    QUALITY_UPGRADE_CHANCE: 0.5,
    DECK_SIZE_LIMIT: 5,
    LEADERBOARD_SIZE: 10,
    SELL_DUPLICATE_SCORE_DIVISOR: 10,
    BATTLE_WIN_SCORE_DIVISOR: 5,
    DAILY_CHALLENGE_SCORE_DIVISOR: 2,
    CHAT_MESSAGE_LIMIT: 50,
    CHAT_MESSAGE_MAX_LENGTH: 150,

    // Bank Constants
    PASSIVE_INCOME_INTERVAL_MS: 5 * 60 * 60 * 1000, // 5 hours
    SAVINGS_INTEREST_INTERVAL_MS: 8 * 60 * 60 * 1000, // 8 hours
    LOAN_INTEREST_INTERVAL_MS: 24 * 60 * 60 * 1000, // 1 day
    SAVINGS_INTEREST_RATE: 0.02, // 2%
    LOAN_INTEREST_RATE: 0.05, // 5%
    MAX_LOAN_AMOUNT: 15000,
    PASSIVE_INCOME_POWER_DIVISOR: 20, // Coins per power for passive income

    // Black Market Constants
    BLACK_MARKET_TICKET_COST: 30000,
    BM_PASSWORDS: {
        purchaseTicket: "purchase1",
        useConsumable: "Blackmarket item42O",
        // useCodeItem: "Codeitems69" // Password for admin-generated consumables
    },
    ULTRA_TOKEN_DROPS: { exclusive_case: 60, exclusive_luck_potion: 30, ultra_lucky_roll: 10 },
    ULTRA_LUCKY_ROLL_REWARDS: { potions: { luck: 1, speed: 1, battle: 1 }, coins: 5000, cardRarity: "celestial" },
    EXCLUSIVE_LUCK_POTION_BONUS: 50, // 50% luck boost

    // Code Redemption Constants
    CODE_PASSWORDS: {
        adminPanel: "34098",
        redemptionAccess: "BETA^($@)", // <-- Updated Password
        reversal: "BOBIS23",
        useCodeItem: "Codeitems69" // Password for admin-generated consumables
    },
    REDEMPTION_COOLDOWN_MS: 1 * 60 * 60 * 1000, // 1 hour
    REDEMPTION_LOCKOUT_MS: 20 * 60 * 60 * 1000, // 20 hours
    ADMIN_CODE_LENGTH: 12,

    // Game Data Definitions
    GRADES: ["E", "D", "C", "B", "A", "S", "SS"],
    GRADE_MULTIPLIERS: { E: 0.8, D: 0.9, C: 1.0, B: 1.1, A: 1.2, S: 1.4, SS: 1.6 },
    QUALITIES: ["destroyed", "ripped", "crumpled", "creased", "Mint condition"],
    QUALITY_MULTIPLIERS: { destroyed: 0.7, ripped: 0.8, crumpled: 0.9, creased: 0.95, "Mint condition": 1.0 },
    POTION_TYPES: ['luck', 'speed', 'battle'],

    // Rarities (ensure this matches CSS colors if used directly)
    RARITIES: [
        { name: "common", prob: 15, color: "#BBBBBB", stats: { min: 5, max: 15 }, value: 5 },
        { name: "uncommon", prob: 10, color: "#00FF00", stats: { min: 10, max: 25 }, value: 10 },
        { name: "rare", prob: 7.5, color: "#00BFFF", stats: { min: 20, max: 40 }, value: 20 },
        { name: "epic", prob: 5, color: "#800080", stats: { min: 35, max: 60 }, value: 40 },
        { name: "legendary", prob: 4, color: "#FFA500", stats: { min: 50, max: 80 }, value: 75 },
        { name: "mythic", prob: 3, color: "#FF4500", stats: { min: 70, max: 110 }, value: 120 },
        { name: "divine", prob: 2, color: "#FFD700", stats: { min: 100, max: 150 }, value: 200 },
        { name: "cosmic", prob: 1, color: "#FF0000", stats: { min: 140, max: 200 }, value: 300 },
        { name: "eternal", prob: 0.1, color: "#00CED1", stats: { min: 180, max: 250 }, value: 500 },
        { name: "celestial", prob: 0.01, color: "#FF69B4", stats: { min: 220, max: 300 }, value: 800 },
        { name: "transcendent", prob: 0.001, color: "#8A2BE2", stats: { min: 280, max: 380 }, value: 1200 },
        { name: "godly", prob: 0.0001, color: "#DAA520", stats: { min: 350, max: 480 }, value: 2000 },
        { name: "extreme", prob: 0.00001, color: "#800000", stats: { min: 450, max: 600 }, value: 3500 },
        { name: "solar", prob: 0.00005, color: "#FF6347", stats: { min: 400, max: 550 }, value: 2800 },
        { name: "galactic", prob: 0.00003, color: "#483D8B", stats: { min: 420, max: 580 }, value: 3000 },
        { name: "universal", prob: 0.000001, color: "#2F4F4F", stats: { min: 500, max: 700 }, value: 5000 },
        { name: "mythos", prob: 0.000005, color: "#A52A2A", stats: { min: 480, max: 650 }, value: 4500 },
        { name: "primal", prob: 0.000002, color: "#FF1493", stats: { min: 490, max: 680 }, value: 4800 },
        { name: "ethereal", prob: 0.0000001, color: "#8B0000", stats: { min: 600, max: 800 }, value: 7000 },
        { name: "restricted", prob: 0.00000005, color: "#556B2F", stats: { min: 700, max: 1000 }, value: 10000 }
    ],

    CASE_PROBABILITIES: {
        basic: { cost: 100, drops: { common: 50, uncommon: 35, rare: 13, epic: 2 }, potionChance: 0.05 },
        premium: { cost: 200, drops: { uncommon: 40, rare: 35, epic: 20, legendary: 5 }, potionChance: 0.10 },
        ultra: { cost: 400, drops: { rare: 40, epic: 30, legendary: 20, mythic: 10 }, potionChance: 0.15 },
        elite: { cost: 800, drops: { epic: 40, legendary: 30, mythic: 20, divine: 10 }, potionChance: 0.20 },
        legendary: { cost: 1200, drops: { legendary: 35, mythic: 30, divine: 20, cosmic: 10, eternal: 5 }, potionChance: 0.25 }
    }
});

// --- DOM Element Cache ---
const DOMElements = {
    // Root and Screens
    body: document.body,
    container: document.querySelector('.container'),
    loginScreen: document.getElementById('loginScreen'),
    gameScreen: document.getElementById('gameScreen'),

    // UI Toggle
    toggleUIButton: document.getElementById('toggleUI'),

    // Login Form
    loginForm: document.getElementById('loginForm'),
    emailInput: document.getElementById('emailInput'),
    passwordInput: document.getElementById('passwordInput'),
    displayNameInput: document.getElementById('displayNameInput'),
    loginActionRadios: document.querySelectorAll('#loginForm input[name="action"]'), // Specific selection

    // Game Header
    userGreeting: document.getElementById('userGreeting'),
    totalPowerDisplaySpan: document.querySelector('#totalPowerDisplay span'),
    currencyDisplaySpan: document.querySelector('#currencyDisplay span'),
    logoutBtn: document.getElementById('logoutBtn'),
    deleteDataBtn: document.getElementById('deleteDataBtn'),

    // Tabs
    tabNav: document.querySelector('.tab-nav'),
    tabButtons: document.querySelectorAll('.tabButton'), // Cache all buttons
    tabContents: document.querySelectorAll('.tabContent'), // Cache all content divs

    // Filters (Common)
    inventoryFilters: document.getElementById('inventoryFilters'),
    deckFilters: document.getElementById('deckFilters'),
    rarityFilterSelect: document.getElementById('rarityFilter'),
    deckRarityFilterSelect: document.getElementById('deckRarityFilter'),

    // Roll Tab
    rollButton: document.getElementById('rollButton'),
    cooldownTimerP: document.getElementById('cooldownTimer'),
    rollResultDiv: document.getElementById('rollResult'),
    flipCardBtn: document.getElementById('flipCardBtn'),
    rarityRolledListUl: document.getElementById('rarityRolledList'),
    boostStatusP: document.getElementById('boostStatus'),
    rollLuckDisplayP: document.getElementById('rollLuckDisplay'),

    // Deck Tab
    deckInventoryListUl: document.getElementById('deckInventoryList'),
    deckListUl: document.getElementById('deckList'),
    deckCountSpan: document.getElementById('deckCount'), // Corrected ID
    deckPowerSpan: document.getElementById('deckPower'),

    // Inventory Tab
    inventoryCountSpan: document.getElementById('inventoryCount'),
    sellDuplicatesBtn: document.getElementById('sellDuplicatesBtn'),
    inventoryListUl: document.getElementById('inventoryList'),

    // Appraisal Tab
    appraisalListUl: document.getElementById('appraisalList'),
    appraisalOverlay: document.getElementById('appraisalOverlay'),
    appraisalCircle: document.getElementById('appraisalCircle'),
    appraisalPopup: document.getElementById('appraisalPopup'),
    appraisalPopupMessage: document.getElementById('appraisalPopupMessage'),
    closeAppraisalPopupBtn: document.getElementById('closeAppraisalPopupBtn'),

    // Upgrades/Potions Tab
    cooldownLevelP: document.getElementById('cooldownLevelDisplay'),
    luckLevelP: document.getElementById('luckLevelDisplay'),
    currentCooldownP: document.getElementById('currentCooldownDisplay'),
    upgradeLuckDisplayP: document.getElementById('upgradeLuckDisplay'),
    upgradeCooldownBtn: document.getElementById('upgradeCooldownBtn'),
    cooldownCostSpan: document.getElementById('cooldownCost'),
    upgradeLuckBtn: document.getElementById('upgradeLuckBtn'),
    luckCostSpan: document.getElementById('luckCost'),
    potionStatusDiv: document.getElementById('potionStatus'),
    luckPotionCountSpan: document.getElementById('luckPotionCount'),
    buyLuckPotionBtn: document.getElementById('buyLuckPotionBtn'),
    useLuckPotionBtn: document.getElementById('useLuckPotionBtn'),
    speedPotionCountSpan: document.getElementById('speedPotionCount'),
    buySpeedPotionBtn: document.getElementById('buySpeedPotionBtn'),
    useSpeedPotionBtn: document.getElementById('useSpeedPotionBtn'),
    battlePotionCountSpan: document.getElementById('battlePotionCount'),
    buyBattlePotionBtn: document.getElementById('buyBattlePotionBtn'),
    useBattlePotionBtn: document.getElementById('useBattlePotionBtn'),

    // Cases Tab
    caseAnimationWrapper: document.getElementById('caseAnimationWrapper'), // Cache wrapper
    caseAnimationDiv: document.getElementById('caseAnimation'),
    caseResultDiv: document.getElementById('caseResult'),
    caseButtonsContainer: document.querySelector('#casesContent .case-buttons'), // Cache button container

    // Battle Tab
    startBattleBtn: document.getElementById('startBattleBtn'),
    battleAreaDiv: document.getElementById('battleArea'),
    turnLogDiv: document.getElementById('turnLogDiv'), // Corrected ID
    nextTurnBtn: document.getElementById('nextTurnBtn'),
    battleResultDiv: document.getElementById('battleResultDiv'),

    // Leaderboard Tab
    playerScoreDisplayP: document.getElementById('playerScoreDisplay'),
    leaderboardListUl: document.getElementById('leaderboardListUl'), // Changed from Div

    // Daily Tab
    dailyChallengeInfoDiv: document.getElementById('dailyChallengeInfo'),
    claimDailyChallengeBtn: document.getElementById('claimDailyChallengeBtn'),
    generateNewChallengeBtn: document.getElementById('generateNewChallengeBtn'),

    // Bank Tab
    passiveIncomeRateP: document.getElementById('passiveIncomeRate'),
    nextPassiveIncomeTimeP: document.getElementById('nextPassiveIncomeTime'),
    savingsBalanceP: document.getElementById('savingsBalance'),
    nextSavingsInterestTimeP: document.getElementById('nextSavingsInterestTime'),
    depositAmountInput: document.getElementById('depositAmount'),
    depositBtn: document.getElementById('depositBtn'),
    withdrawBtn: document.getElementById('withdrawBtn'),
    loanAmountDisplayP: document.getElementById('loanAmountDisplay'),
    nextLoanInterestTimeP: document.getElementById('nextLoanInterestTime'),
    loanRequestAmountInput: document.getElementById('loanRequestAmount'),
    takeLoanBtn: document.getElementById('takeLoanBtn'),
    repayLoanAmountInput: document.getElementById('repayLoanAmount'),
    repayLoanBtn: document.getElementById('repayLoanBtn'),

    // Chat Tab
    chatMessages: document.getElementById('chatMessages'),
    chatInput: document.getElementById('chatInput'),
    sendChatBtn: document.getElementById('sendChatBtn'),

    // Black Market Tab
    buyMarketTicketBtn: document.getElementById('buyMarketTicketBtn'),
    useMarketTicketBtn: document.getElementById('useMarketTicketBtn'),
    useUltraTokenBtn: document.getElementById('useUltraTokenBtn'),
    marketTicketCountSpan: document.getElementById('marketTicketCount'),
    ultraTokenCountSpan: document.getElementById('ultraTokenCount'),
    exclusiveCaseCountSpan: document.getElementById('exclusiveCaseCount'),
    useExclusiveCaseBtn: document.getElementById('useExclusiveCaseBtn'),
    exclusiveLuckPotionCountSpan: document.getElementById('exclusiveLuckPotionCount'),
    useExclusiveLuckPotionBtn: document.getElementById('useExclusiveLuckPotionBtn'),
    ultraLuckyRollCountSpan: document.getElementById('ultraLuckyRollCount'),
    useUltraLuckyRollBtn: document.getElementById('useUltraLuckyRollBtn'),
    marketItemListUl: document.getElementById('marketItemList'), // Cache the list itself

    // Redemption Tab
    redemptionPasswordPrompt: document.getElementById('redemptionPasswordPrompt'),
    redemptionPasswordInput: document.getElementById('redemptionPasswordInput'),
    redemptionUnlockBtn: document.getElementById('redemptionUnlockBtn'),
    redemptionInterface: document.getElementById('redemptionInterface'),
    redemptionStatus: document.getElementById('redemptionStatus'),
    redemptionCooldown: document.getElementById('redemptionCooldown'),
    redemptionLockout: document.getElementById('redemptionLockout'),
    redemptionCodeInput: document.getElementById('redemptionCodeInput'),
    redeemCodeBtn: document.getElementById('redeemCodeBtn'),
    reversalCodePrompt: document.getElementById('reversalCodePrompt'),
    reversalCodeInput: document.getElementById('reversalCodeInput'),
    submitReversalBtn: document.getElementById('submitReversalBtn'),

    // Admin Panel
    adminPanel: document.getElementById('adminPanel'),
    adminPasswordSection: document.getElementById('adminPasswordSection'),
    adminPasswordInput: document.getElementById('adminPasswordInput'),
    adminLoginBtn: document.getElementById('adminLoginBtn'),
    adminGeneratorSection: document.getElementById('adminGeneratorSection'),
    adminCurrencyButtons: document.getElementById('adminCurrencyButtons'),
    adminCaseButtons: document.getElementById('adminCaseButtons'),
    adminPotionButtons: document.getElementById('adminPotionButtons'),
    adminRarityButtons: document.getElementById('adminRarityButtons'),
    adminBlackMarketButtons: document.getElementById('adminBlackMarketButtons'),
    adminSelectionInfo: document.getElementById('adminSelectionInfo'),
    adminGenerateCodeBtn: document.getElementById('adminGenerateCodeBtn'),
    adminCodeOutput: document.getElementById('adminCodeOutput'),
    adminCloseBtn: document.getElementById('adminCloseBtn'),
    adminExpiryDateInput: document.getElementById('adminExpiryDateInput'),
    // Profile Edit Elements (New)
    profileBtn: document.getElementById('profileBtn'),
    profileModal: document.getElementById('profileModal'),
    newNameInput: document.getElementById('newNameInput'),
    saveNameBtn: document.getElementById('saveNameBtn'),
    closeProfileBtn: document.getElementById('closeProfileBtn'),
    profileStatusMsg: document.getElementById('profileStatusMsg'),
};

// --- Utility Functions ---
const Utils = {
    log: (level, ...args) => { // Simple logger
        if (level === 'error') console.error(...args);
        else if (level === 'warn') console.warn(...args);
        else console.log(...args);
    },
    capitalize: (s) => {
        if (typeof s !== 'string' || s.length === 0) return '';
        return s.charAt(0).toUpperCase() + s.slice(1);
    },
    getRandomInt: (min, max) => {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    },
    // No audio functions needed
    // playSound: (soundElement) => { /* Removed */ },
    showElement: (element) => element?.classList.remove('hidden'),
    hideElement: (element) => element?.classList.add('hidden'),
    setActive: (element) => element?.classList.add('active'),
    setInactive: (element) => element?.classList.remove('active'),
    enableButton: (button, condition = true) => { if (button) button.disabled = !condition; },
    disableButton: (button) => { if (button) button.disabled = true; },
    formatTimeRemaining: (ms) => {
        if (ms <= 0) return "Now";
        const totalSeconds = Math.max(0, Math.floor(ms / 1000));
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        let str = "";
        if (hours > 0) str += `${hours}h `;
        if (minutes > 0 || hours > 0) str += `${minutes}m `;
        str += `${seconds}s`;
        return str.trim() || "0s";
    },
    debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func.apply(this, args); // Use apply to preserve context
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },
    addListener: (element, event, handler, options = {}) => {
        if (element) {
            element.addEventListener(event, handler, options);
        } else {
            // Log warning only once per missing element to avoid spamming console
            const key = `${event}-${handler.name || 'anonymous'}`;
            if (!Utils._warnedMissingElements) Utils._warnedMissingElements = {};
            if (!Utils._warnedMissingElements[key]) {
                Utils.log('warn', `Attempted to add listener for '${event}' to a non-existent element.`);
                Utils._warnedMissingElements[key] = true;
            }
        }
    },
    // Function to safely get nested property
    getNestedProp: (obj, path, defaultValue = undefined) => {
        const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
        return value !== undefined ? value : defaultValue;
    },
    generateRandomCode: (length) => {
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            const randomIndex = Math.floor(Math.random() * characters.length);
            result += characters[randomIndex];
        }
        return result;
    }
};

// --- Data Persistence (Firestore Wrapper) ---
const Firestore = {
    // Update specific fields in the user document
    updateUserData: async (updates) => {
        if (!AppState.currentUserId) {
            Utils.log('error', "Firestore Update Failed: No user logged in.");
            return Promise.reject("User not logged in");
        }
        if (typeof updates !== 'object' || updates === null || Object.keys(updates).length === 0) {
            Utils.log('warn', "Firestore update called with invalid or empty updates.");
            return Promise.resolve(); // No-op
        }

        Utils.log('info', "Updating Firestore for user:", AppState.currentUserId, updates);
        const userRef = AppState.db.collection('users').doc(AppState.currentUserId);
        try {
            await userRef.update(updates);
            Utils.log('info', "Firestore update successful.");
        } catch (error) {
            Utils.log('error', "Firestore update failed:", error);
            alert(`Failed to save progress: ${error.message}`); // Notify user
            return Promise.reject(error);
        }
    },

    // Increment a numeric field
    incrementUserField: async (fieldName, value) => {
        if (typeof value !== 'number' || value === 0) {
            Utils.log('warn', `Firestore increment called with non-numeric or zero value for ${fieldName}.`);
            return Promise.resolve();
        }
        return Firestore.updateUserData({
            [fieldName]: firebase.firestore.FieldValue.increment(value)
        });
    },

    // Add an item to an array field (e.g., inventory)
    addUserArrayItem: async (arrayFieldName, item) => {
        if (!item || typeof item !== 'object') {
            Utils.log('error', `Firestore addUserArrayItem failed: Invalid item for field ${arrayFieldName}.`);
            return Promise.reject("Invalid item");
        }
        return Firestore.updateUserData({
            [arrayFieldName]: firebase.firestore.FieldValue.arrayUnion(item)
        });
    },

    // Remove an item from an array field using the item object itself
    removeUserArrayItem: async (arrayFieldName, itemToRemove) => {
        if (!itemToRemove || typeof itemToRemove !== 'object') {
            Utils.log('error', `Firestore removeUserArrayItem failed: Invalid item to remove for field ${arrayFieldName}.`);
            return Promise.reject("Invalid item to remove");
        }
        return Firestore.updateUserData({
            [arrayFieldName]: firebase.firestore.FieldValue.arrayRemove(itemToRemove)
        });
    },

    // Remove an item from an array field by its ID (more complex, requires local cache)
    removeUserArrayItemById: async (arrayFieldName, itemId) => {
        if (!AppState.currentUserId) return Promise.reject("User not logged in");
        if (!itemId) return Promise.reject("Invalid item ID");

        const currentArray = Utils.getNestedProp(AppState.userData, arrayFieldName, []);
        const itemToRemove = currentArray.find(item => item && item.id === itemId);

        if (!itemToRemove) {
            Utils.log('warn', `Item ${itemId} not found in local cache of '${arrayFieldName}' for removal.`);
            // Could be listener delay or item already removed. Proceed gracefully.
            return Promise.resolve();
        }
        // Now use the found item object for removal
        return Firestore.removeUserArrayItem(arrayFieldName, itemToRemove);
    },

    // Set the entire user document (use with caution, merge recommended)
    setUserDocument: async (data, merge = true) => {
        if (!AppState.currentUserId) {
            Utils.log('error', "Firestore Set Failed: No user logged in.");
            return Promise.reject("User not logged in");
        }
        Utils.log('info', `Setting Firestore document (merge=${merge}) for user:`, AppState.currentUserId, data);
        const userRef = AppState.db.collection('users').doc(AppState.currentUserId);
        try {
            await userRef.set(data, { merge: merge });
            Utils.log('info', "Firestore set successful.");
        } catch (error) {
            Utils.log('error', "Firestore set failed:", error);
            alert(`Failed to save profile data: ${error.message}`);
            return Promise.reject(error);
        }
    },

    // Generic Firestore operations (if needed outside user data)
    addDocument: async (collectionPath, data) => {
        Utils.log('info', `Adding document to ${collectionPath}:`, data);
        try {
            const docRef = await AppState.db.collection(collectionPath).add(data);
            Utils.log('info', `Document added successfully with ID: ${docRef.id}`);
            return docRef;
        } catch (error) {
            Utils.log('error', `Failed to add document to ${collectionPath}:`, error);
            alert(`Operation failed: ${error.message}`);
            return Promise.reject(error);
        }
    },

    setDocument: async (collectionPath, docId, data, merge = true) => {
        Utils.log('info', `Setting document ${docId} in ${collectionPath} (merge=${merge}):`, data);
        try {
            const docRef = AppState.db.collection(collectionPath).doc(docId);
            await docRef.set(data, { merge: merge });
            Utils.log('info', `Document ${docId} set successfully.`);
        } catch (error) {
            Utils.log('error', `Failed to set document ${docId} in ${collectionPath}:`, error);
            alert(`Operation failed: ${error.message}`);
            return Promise.reject(error);
        }
    },

    deleteDocument: async (collectionPath, docId) => {
        Utils.log('warn', `Deleting document ${docId} from ${collectionPath}`);
        try {
            await AppState.db.collection(collectionPath).doc(docId).delete();
            Utils.log('info', `Document ${docId} deleted successfully.`);
        } catch (error) {
            Utils.log('error', `Failed to delete document ${docId} from ${collectionPath}:`, error);
            alert(`Deletion failed: ${error.message}`);
            return Promise.reject(error);
        }
    },
}; // End Firestore Object

// --- Authentication Module ---
const Auth = {
    initialize: () => {
        Utils.log('info', "Auth.initialize STARTING..."); // <-- ADDED
        try {
            AppState.auth = firebase.auth();

            // Attach listener for auth state changes
            AppState.auth.onAuthStateChanged((user) => {
                if (user) {
                    Utils.log('info', "Auth State Changed: User logged in", user.uid);
                    Auth.handleUserLoggedIn(user);
                } else {
                    Utils.log('info', "Auth State Changed: User logged out");
                    Auth.handleUserLoggedOut();
                }
            });

            // --- Login Form Listener Setup ---
            Utils.log('info', 'Attempting to attach listener. Login form element:', DOMElements.loginForm); // <-- ADDED Check
            if (DOMElements.loginForm) { // <-- ADDED Check if element exists
                Utils.addListener(DOMElements.loginForm, 'submit', Auth.handleLoginSignup);
                Utils.log('info', '>>> Attached submit listener to login form.');
            } else {
                Utils.log('error', '!!! FAILED to attach submit listener: DOMElements.loginForm is null or undefined!'); // <-- ADDED Error log
            }
            // --- End Login Form Listener Setup ---

            DOMElements.loginActionRadios.forEach(radio => {
                Utils.addListener(radio, 'change', Auth.handleLoginActionToggle);
            });
            Utils.log('info', "Auth.initialize FINISHED successfully."); // <-- ADDED
        } catch (initError) {
            Utils.log('error', '!!! CRITICAL ERROR during Auth.initialize !!!', initError);
            alert('Critical error initializing authentication. Check console!');
        }
    },

    handleLoginActionToggle: (event) => {
        if (event.target.value === 'signup') {
            Utils.showElement(DOMElements.displayNameInput);
        } else {
            Utils.hideElement(DOMElements.displayNameInput);
        }
    },

    handleLoginSignup: async (event) => {
        try { // <--- ADDED Outer Try/Catch
            event.preventDefault();
            Utils.log('info', '>>> event.preventDefault() CALLED.'); // <--- ADDED Log

            Utils.log('info', 'Login/Signup initiated.');
            Utils.disableButton(DOMElements.loginForm.querySelector('button[type="submit"]'));
            const email = DOMElements.emailInput.value.trim();
            const password = DOMElements.passwordInput.value;
            const displayName = DOMElements.displayNameInput.value.trim();
            const action = DOMElements.loginForm.querySelector('input[name="action"]:checked')?.value;

            Utils.log('info', `Action: ${action}, Email: ${email}`);

            if (!action) {
                alert("Please select Login or Sign Up.");
                Utils.enableButton(DOMElements.loginForm.querySelector('button[type="submit"]'));
                return;
            }
            if (!email || !password) {
                alert("Please fill in both email and password.");
                Utils.enableButton(DOMElements.loginForm.querySelector('button[type="submit"]'));
                return;
            }
            if (action === "signup" && !displayName) {
                alert("Please enter a display name for sign up.");
                Utils.enableButton(DOMElements.loginForm.querySelector('button[type="submit"]'));
                return;
            }

            // Inner try/catch for Firebase operations remains
            try {
                if (action === "login") {
                    Utils.log('info', "Attempting Firebase login...");
                    await AppState.auth.signInWithEmailAndPassword(email, password);
                    Utils.log('info', "Firebase login successful trigger for:", email);
                } else if (action === "signup") {
                    Utils.log('info', "Attempting Firebase signup...");
                    const userCredential = await AppState.auth.createUserWithEmailAndPassword(email, password);
                    Utils.log('info', "Firebase signup successful for:", email, "UID:", userCredential.user.uid);
                    await Auth.initializeNewUserData(userCredential.user.uid, email, displayName);
                }
            } catch (error) {
                Utils.log('error', `Firebase ${action} error:`, error);
                alert(`Error during ${action}: ${error.message}`);
                Utils.enableButton(DOMElements.loginForm.querySelector('button[type="submit"]'));
            }
        } catch (outerError) { // <--- ADDED Catch for outer block
            Utils.log('error', '!!! UNEXPECTED ERROR in handleLoginSignup !!!', outerError);
            alert('An unexpected error occurred during login/signup. Check console!');
            // Try to re-enable button even if something went wrong
            Utils.enableButton(DOMElements.loginForm?.querySelector('button[type="submit"]'));
        }
    },

    initializeNewUserData: async (uid, email, displayName) => {
        const newUser = Auth.createDefaultUserData(displayName, email);
        Utils.log('info', "Creating initial Firestore document for new user:", uid);
        try {
            // Use set without merge for new user to ensure clean slate
            await Firestore.setDocument('users', uid, newUser, false);
            Utils.log('info', "Firestore document created successfully for", uid);
        } catch (error) {
            Utils.log('error', "Error creating Firestore document for new user:", error);
            alert("Error setting up user profile. Please try logging in again.");
            // Consider deleting the auth user if doc creation failed critically? Risky.
        }
    },

    createDefaultUserData: (displayName, email) => ({
        displayName: displayName,
        email: email,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        // Game Data Defaults
        currency: 100,
        playerScore: 0,
        cooldownLevel: 0,
        luckLevel: 0,
        inventory: [],
        deck: [],
        potions: { luck: 0, speed: 0, battle: 0 },
        dailyChallenge: null,
        bankSavings: 0,
        loanAmount: 0,
        lastPassiveIncomeTimestamp: Date.now(), // Set initial timestamp
        lastSavingsTimestamp: 0,
        lastLoanInterestTimestamp: 0,
        blackMarketTickets: 0,
        ultraTokens: 0,
        consumables: { exclusive_case: 0, exclusive_luck_potion: 0, ultra_lucky_roll: 0 },
        redemption: { lastAttemptTimestamp: 0, lockoutUntilTimestamp: 0, isLockedOut: false },
        battleBoostActive: false, // Ensure boost flag is initialized
        redemptionLockoutUntil: null,
        lastDisplayNameChange: null, // Added for profile edit cooldown
        // Initialize other fields as needed
        singlePlayerScore: 0, // Explicitly adding single-player score
        multiplayerScore: 0, // Added for multiplayer
    }),

    handleUserLoggedIn: (user) => {
        AppState.currentUser = user;
        AppState.currentUserId = user.uid;
        Utils.log('info', `User ${user.uid} logged in. Setting up listeners and UI.`);

        // --- Setup Firestore Listeners --- //
        Auth.detachListeners(); // Ensure previous listeners are removed

        const userRef = AppState.db.collection('users').doc(user.uid);
        AppState.unsubscribeUserData = userRef.onSnapshot(Auth.onUserDataSnapshot, Auth.onListenerError('UserData'));

        // Leaderboard Listener (Top 50 by singlePlayerScore for now)
        // TODO: Add sorting/filtering for multiplayer score later
        const leaderboardQuery = AppState.db.collection('users')
            .orderBy('singlePlayerScore', 'desc')
            .limit(50);
        AppState.unsubscribeLeaderboard = leaderboardQuery.onSnapshot(Auth.onLeaderboardSnapshot, Auth.onListenerError('Leaderboard'));
        Utils.log('info', "Attached Leaderboard listener.");

        const chatQuery = AppState.db.collection('chatMessages').orderBy('timestamp', 'desc').limit(Constants.CHAT_MESSAGE_LIMIT);
        AppState.unsubscribeChat = chatQuery.onSnapshot(Auth.onChatSnapshot, Auth.onListenerError('Chat'));

        // Load local-only state (needs migration strategy)
        AppState.globalCardIdCounter = parseInt(localStorage.getItem("globalCardIdCounter_v2") || "0"); // TODO: Migrate

        // Initial UI switch (happens before data snapshot)
        UI.showScreen('gameScreen');
    },

    onUserDataSnapshot: (doc) => {
        if (doc.exists) {
            Utils.log('info', "Firestore UserData received for:", AppState.currentUserId);
            const loadedData = doc.data();
            const defaults = Auth.createDefaultUserData('', '');
            let dataChanged = false;

            // Initialize missing top-level fields and nested objects
            for (const key in defaults) {
                if (!(key in loadedData)) {
                    loadedData[key] = defaults[key];
                    dataChanged = true;
                    Utils.log('warn', `Initialized missing user data key: ${key}`);
                } else if (typeof defaults[key] === 'object' && defaults[key] !== null && typeof loadedData[key] !== 'object') {
                    // Handle cases where a field should be an object but isn't (e.g., old data format)
                    loadedData[key] = defaults[key];
                    dataChanged = true;
                    Utils.log('warn', `Re-initialized invalid user data key: ${key}`);
                } else if (key === 'redemption' && typeof loadedData[key] === 'object') { // Deeper check for nested objects
                    for (const subKey in defaults.redemption) {
                        if (!(subKey in loadedData.redemption)) {
                            loadedData.redemption[subKey] = defaults.redemption[subKey];
                            dataChanged = true;
                            Utils.log('warn', `Initialized missing user data key: redemption.${subKey}`);
                        }
                    }
                }
                else if (key === 'consumables' && typeof loadedData[key] === 'object') {
                    for (const subKey in defaults.consumables) {
                        if (!(subKey in loadedData.consumables)) {
                            loadedData.consumables[subKey] = defaults.consumables[subKey];
                            dataChanged = true;
                            Utils.log('warn', `Initialized missing user data key: consumables.${subKey}`);
                        }
                    }
                }
                else if (key === 'potions' && typeof loadedData[key] === 'object') {
                    for (const subKey in defaults.potions) {
                        if (!(subKey in loadedData.potions)) {
                            loadedData.potions[subKey] = defaults.potions[subKey];
                            dataChanged = true;
                            Utils.log('warn', `Initialized missing user data key: potions.${subKey}`);
                        }
                    }
                }
            }
            // Ensure boost active flags are booleans
            AppState.activeBoosts.battle.active = !!loadedData.battleBoostActive; // Sync battle boost state

            AppState.userData = loadedData; // Update local cache

            // Process offline bank changes AFTER data is loaded
            const bankChanges = Bank.processOfflineChanges(); // Calculate changes based on new data
            Bank.saveOfflineBankChanges(bankChanges); // Save if needed (async)

            // --- Initialize Game Modules and Full UI Update ---
            // This happens *after* the first data snapshot
            Auth.initializeGameModules(); // Setup game listeners
            UI.updateAll(); // Perform full UI update based on loaded data

            // If default fields were added, save back to Firestore
            if (dataChanged) {
                Utils.log('info', "Saving initialized/missing user data fields back to Firestore...");
                // Use set with merge to add missing fields without overwriting existing ones
                Firestore.setUserDocument(AppState.userData, true).catch(err => {
                    Utils.log('error', "Error saving initialized data:", err);
                });
            }

        } else {
            Utils.log('error', "CRITICAL: Firestore document missing for logged-in user!", AppState.currentUserId);
            alert("Error: User profile data not found. Please contact support or try signing up again.");
            Auth.logout(); // Log out the broken user state
        }
    },

    onLeaderboardSnapshot: (querySnapshot) => {
        const leaderboardData = [];
        querySnapshot.forEach((doc) => {
            leaderboardData.push({
                name: doc.data().displayName || `User_${doc.id.substring(0, 6)}`, // Fallback name
                spScore: doc.data().singlePlayerScore || 0, // Use singlePlayerScore
                mpScore: doc.data().multiplayerScore || 0, // Add multiplayerScore
                uid: doc.id
            });
        });
        Utils.log('info', "Leaderboard data received:", leaderboardData.length, "entries");
        UI.updateLeaderboard(leaderboardData);
    },

    onChatSnapshot: (querySnapshot) => {
        const chatMessages = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            const timestamp = data.timestamp ? data.timestamp.toDate() : new Date(); // Handle potential missing timestamp
            chatMessages.push({
                id: doc.id,
                displayName: data.displayName || 'Anon',
                message: data.message || '',
                timestamp: timestamp
            });
        });
        Utils.log('info', "Chat messages received:", chatMessages.length, "entries");
        UI.updateChatMessages(chatMessages.reverse()); // Reverse for chronological display
    },

    onListenerError: (listenerName) => (error) => {
        Utils.log('error', `${listenerName} Firestore listener error:`, error);
        alert(`Error receiving ${listenerName.toLowerCase()} updates. Functionality may be affected. Please refresh.`);
        // Optionally try to re-attach listener or guide user
    },

    // Separate function to initialize game modules AFTER login and first data load
    _gameModulesInitialized: false,
    initializeGameModules: () => {
        if (Auth._gameModulesInitialized) return; // Only initialize once
        Utils.log('info', "Initializing Game Modules (Post-Login)...");

        if (DOMElements.chatInput) DOMElements.chatInput.disabled = false;
        if (DOMElements.sendChatBtn) DOMElements.sendChatBtn.disabled = false;
        UI.initializeGameUI(); // Setup tab listeners, header buttons etc.
        Roll.initialize();
        Deck.initialize();
        Inventory.initialize();
        Appraisal.initialize();
        Upgrades.initialize();
        Cases.initialize();
        Battle.initialize();
        Leaderboard.initialize();
        DailyChallenge.initialize();
        Bank.initialize();
        Chat.initialize();
        BlackMarket.initialize();
        Redemption.initialize();
        AdminPanel.initialize();
        Profile.initialize(); // Initialize Profile module

        Auth._gameModulesInitialized = true; // Set flag
        Utils.log('info', "Game modules initialized.");
    },

    handleUserLoggedOut: () => {
        Auth.detachListeners(); // Stop listening to Firestore
        Auth._gameModulesInitialized = false; // Reset flag for next login

        // Clear local state
        AppState.currentUser = null;
        AppState.currentUserId = null;
        AppState.userData = {};

        // Clear potentially sensitive timers/intervals
        Object.values(AppState.activeBoosts).forEach(boost => {
            if (boost.timer) clearInterval(boost.timer);
            boost.active = false;
            boost.remaining = 0;
        });
        if (AppState.rollCooldownTimer) clearInterval(AppState.rollCooldownTimer);
        AppState.isRolling = false;

        // Reset admin state
        AppState.adminPanel.isVisible = false;
        AppState.adminPanel.isLoggedIn = false;
        AppState.adminPanel.selectedItems = [];

        // Reset redemption state and clear session storage
        AppState.redemptionUnlocked = false;
        sessionStorage.removeItem('redemptionUnlocked');
        Utils.log('info', 'Cleared redemption session storage on logout.');
        if (DOMElements.chatInput) {
            DOMElements.chatInput.disabled = true;
            DOMElements.chatInput.value = '';
        }
        if (DOMElements.sendChatBtn) DOMElements.sendChatBtn.disabled = true;

        // Reset UI to login screen
        UI.resetUIForLogout();
        Utils.log('info', "User logged out, UI reset.");
    },

    logout: async () => {
        if (!AppState.currentUser) return;
        Utils.log('info', "Attempting Firebase logout...");
        try {
            // Explicitly save any final local state if needed
            localStorage.setItem("globalCardIdCounter_v2", AppState.globalCardIdCounter.toString());

            await AppState.auth.signOut();
            Utils.log('info', "Firebase logout successful trigger.");
            // onAuthStateChanged handles the rest
        } catch (error) {
            Utils.log('error', "Firebase logout error:", error);
            alert(`Logout failed: ${error.message}`);
        }
    },

    deleteUserData: async () => {
        if (!AppState.currentUser || !AppState.currentUserId) return;
        const userId = AppState.currentUserId;
        const userEmail = AppState.currentUser.email;

        if (confirm(`ARE YOU ABSOLUTELY SURE?\n\nYou want to delete all data AND the account for ${userEmail}?\n\nThis cannot be undone.`)) {
            try {
                Utils.log('warn', `Deleting Firestore data for user: ${userId}`);
                await Firestore.deleteDocument('users', userId);
                Utils.log('warn', `Firestore data deleted. Now deleting Firebase Auth user: ${userId}`);
                await AppState.currentUser.delete();
                alert("Account and all associated data deleted successfully.");
                Utils.log('warn', `Successfully deleted account and data for user: ${userId}`);

            } catch (error) {
                Utils.log('error', "Error deleting user account/data:", error);
                if (error.code === 'auth/requires-recent-login') {
                    alert("For security, please log out and log back in again before deleting your account.");
                    Auth.logout();
                } else {
                    alert(`Error deleting account: ${error.message}`);
                }
            }
        }
    },

    // Helper to detach all Firestore listeners
    detachListeners: () => {
        if (AppState.unsubscribeUserData) {
            Utils.log('info', "Detaching UserData listener.");
            AppState.unsubscribeUserData();
            AppState.unsubscribeUserData = null;
        }
        if (AppState.unsubscribeLeaderboard) {
            Utils.log('info', "Detaching Leaderboard listener.");
            AppState.unsubscribeLeaderboard();
            AppState.unsubscribeLeaderboard = null;
        }
        if (AppState.unsubscribeChat) {
            Utils.log('info', "Detaching Chat listener.");
            AppState.unsubscribeChat();
            AppState.unsubscribeChat = null;
        }
    }
}; // End Auth Module

// --- UI Module ---
const UI = {
    initializeBase: () => {
        Utils.log('info', "Initializing Base UI elements (pre-login)...");
        Utils.addListener(DOMElements.toggleUIButton, 'click', UI.toggleUIMode);
        Utils.addListener(document, 'keydown', UI.handleGlobalKeydown);
        Utils.addListener(window, 'beforeunload', UI.handleBeforeUnload);
        Utils.addListener(document, 'visibilitychange', UI.handleVisibilityChange);
    },

    initializeGameUI: () => {
        Utils.log('info', "Initializing Game UI elements (post-login)...");
        Utils.addListener(DOMElements.tabNav, 'click', UI.handleTabClick);
        Utils.addListener(DOMElements.logoutBtn, 'click', Auth.logout);
        Utils.addListener(DOMElements.deleteDataBtn, 'click', Auth.deleteUserData);
        Utils.addListener(DOMElements.rarityFilterSelect, 'change', Inventory.updateList);
        Utils.addListener(DOMElements.deckRarityFilterSelect, 'change', Deck.updateLists);
        Utils.addListener(DOMElements.closeAppraisalPopupBtn, 'click', UI.closeAppraisalPopup);

        UI.populateStaticDataOnce();
        UI.showTab(AppState.activeTab); // Ensure correct tab is active
    },

    // --- Global Event Handlers ---
handleGlobalKeydown: (e) => {
    if (e.shiftKey && e.key.toUpperCase() === 'C') {
        e.preventDefault();
        AdminPanel.toggleVisibility();
    } 
},
    handleBeforeUnload: () => {
        localStorage.setItem("globalCardIdCounter_v2", AppState.globalCardIdCounter.toString());
        Utils.log('info', "Beforeunload: Saved local state.");
    },
    handleVisibilityChange: () => {
        if (document.visibilityState === 'hidden') {
            localStorage.setItem("globalCardIdCounter_v2", AppState.globalCardIdCounter.toString());
            Utils.log('info', "VisibilityChange (hidden): Saved local state.");
        }
    },

    // --- Core Update Function ---
    updateAll: () => {
        if (!AppState.currentUserId || !AppState.userData) return;
        Utils.log('info', "UI.updateAll triggered.");
        UI.updateHeader();
        UI.updateBoostStatus();
        Upgrades.updateDisplay();
        Inventory.updateList();
        Deck.updateLists();
        Appraisal.updateList();
        Leaderboard.updateDisplay();
        DailyChallenge.updateDisplay();
        Bank.updateDisplay();
        BlackMarket.updateDisplay();
        Redemption.updateRedemptionUI();
    },

    // --- Screen & Tab Management ---
    showScreen: (screenId) => {
        Utils.log('info', `Showing screen: ${screenId}`);
        Utils.setInactive(DOMElements.loginScreen);
        Utils.setInactive(DOMElements.gameScreen);
        const screenToShow = document.getElementById(screenId);
        if (screenToShow) Utils.setActive(screenToShow);
        else Utils.log('error', `Screen element not found: ${screenId}`);
    },

    handleTabClick: (event) => {
        if (event.target.classList.contains('tabButton')) {
            const tabName = event.target.dataset.tab;
            if (tabName) UI.showTab(tabName);
        }
    },

    showTab: (tabName) => {
        if (!tabName || !AppState.currentUserId) return;
        Utils.log('info', `Switching to tab: ${tabName}`);
        AppState.activeTab = tabName;

        DOMElements.tabContents.forEach(tab => Utils.setInactive(tab));
        DOMElements.tabButtons.forEach(btn => Utils.setInactive(btn));

        const contentToShow = document.getElementById(tabName + "Content");
        const buttonToActivate = DOMElements.tabNav.querySelector(`[data-tab="${tabName}"]`);

        if (contentToShow) Utils.setActive(contentToShow);
        if (buttonToActivate) Utils.setActive(buttonToActivate);

        Utils.hideElement(DOMElements.inventoryFilters);
        Utils.hideElement(DOMElements.deckFilters);
        if (tabName === 'inventory') {
            Utils.showElement(DOMElements.inventoryFilters);
            Inventory.updateList();
        } else if (tabName === 'deck') {
            Utils.showElement(DOMElements.deckFilters);
            Deck.updateLists();
        } else if (tabName === 'bank') {
            Bank.updateDisplay();
        } else if (tabName === 'appraisal') {
            Appraisal.updateList();
        }
        buttonToActivate?.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
    },

    // --- Specific UI Update Functions ---
    updateHeader: () => {
        if (!AppState.userData || !DOMElements.userGreeting) return;
        DOMElements.userGreeting.innerText = `Welcome, ${AppState.userData.displayName || AppState.currentUser?.email || 'User'}`;
        if (DOMElements.totalPowerDisplaySpan) DOMElements.totalPowerDisplaySpan.innerText = GameLogic.calculateTotalPower();
        if (DOMElements.currencyDisplaySpan) DOMElements.currencyDisplaySpan.innerText = AppState.userData.currency || 0;
    },

    updateBoostStatus: () => {
        let boostText = "";
        const now = Date.now();
        Object.entries(AppState.activeBoosts).forEach(([key, boost]) => {
            if (boost.active && key !== 'battle') { // Timed boosts
                const endTime = boost.remaining;
                const remainingMs = endTime - now;
                if (remainingMs > 0) {
                    let label = Utils.capitalize(key);
                    if (key === 'exclusiveLuck') label = `Exclusive Luck (+${Constants.EXCLUSIVE_LUCK_POTION_BONUS}%)`;
                    boostText += `${label}: ${Utils.formatTimeRemaining(remainingMs)}. `;
                } else {
                    // Mark as inactive locally if timer expired (interval handles cleanup)
                    boost.active = false;
                }
            }
        });

        if (DOMElements.potionStatusDiv) {
            DOMElements.potionStatusDiv.innerText = AppState.activeBoosts.battle.active ? "Battle Boost Pending!" : "";
        }
        if (DOMElements.boostStatusP) DOMElements.boostStatusP.innerText = boostText.trim();
    },

    // --- List Rendering ---
    renderList: (listElement, items, renderItemFunc, emptyMessage) => {
        if (!listElement) return;
        listElement.innerHTML = "";
        if (!items || items.length === 0) {
            listElement.innerHTML = `<li>${emptyMessage}</li>`;
            return;
        }
        const fragment = document.createDocumentFragment();
        items.forEach(item => {
            const li = renderItemFunc(item);
            if (li instanceof Node) fragment.appendChild(li);
        });
        listElement.appendChild(fragment);
    },

    createCardListItem: (card, actions = []) => {
        if (!card || !card.id) return null;
        const li = document.createElement('li');
        li.dataset.cardId = card.id;
        li.innerHTML = `
                             <strong style="color:${card.color || '#FFF'};">${card.name || 'Unnamed Card'}</strong> (${Utils.capitalize(card.rarity || 'common')}) - Value: ${card.value || 0}<br>
                             Grade: ${card.grade || 'N/A'}, Quality: ${card.quality || 'N/A'}<br>
                             Stats: ATK ${card.attack || 0} / DEF ${card.defense || 0}<br>
                             <em>Ability: ${card.ability?.description || 'None'}</em>
                             <div class="card-actions"></div>
                         `;
        const actionsContainer = li.querySelector('.card-actions');
        if (actionsContainer) {
            actions.forEach(action => {
                if (action) {
                    const button = document.createElement('button');
                    button.textContent = action.text || 'Action';
                    button.disabled = action.disabled || false;
                    button.className = `btn btn-small ${action.class || 'btn-secondary'}`;
                    // Add data attributes for delegated handlers instead of direct onclick
                    button.dataset.action = action.text.toLowerCase().replace(/\s+/g, '-'); // Replace all spaces with hyphens
                    actionsContainer.appendChild(button);
                }
            });
        }
        return li;
    },

    updateLeaderboard: (leaderboardData = []) => {
        UI.renderList(
            DOMElements.leaderboardListUl,
            leaderboardData,
            (entry) => {
                const li = document.createElement("li");
                li.textContent = `${entry.name} - SP Score: ${entry.spScore} | MP Score: ${entry.mpScore}`;
                if (entry.uid === AppState.currentUserId) li.classList.add('current-user');
                return li;
            },
            "Leaderboard is empty."
        );
        if (DOMElements.playerScoreDisplayP) {
            DOMElements.playerScoreDisplayP.innerText = `Your Scores - SP: ${AppState.userData?.singlePlayerScore || 0} | MP: ${AppState.userData?.multiplayerScore || 0}`;
        }
    },

    updateChatMessages: (messages = []) => {
        if (!DOMElements.chatMessages) return;
        DOMElements.chatMessages.innerHTML = '';
        if (messages.length === 0) {
            DOMElements.chatMessages.innerHTML = '<p>No messages yet.</p>';
            return;
        }
        const fragment = document.createDocumentFragment();
        let shouldScroll = DOMElements.chatMessages.scrollHeight - DOMElements.chatMessages.clientHeight <= DOMElements.chatMessages.scrollTop + 1;

        messages.forEach(msg => {
            if (!msg || !msg.timestamp) return;
            const p = document.createElement('p');
            const nameSpan = document.createElement('span');
            nameSpan.className = 'username';
            nameSpan.textContent = `${msg.displayName}: `;
            const msgSpan = document.createElement('span');
            msgSpan.textContent = msg.message;
            const timeSpan = document.createElement('span');
            timeSpan.className = 'timestamp';
            try {
                timeSpan.textContent = msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } catch (e) { timeSpan.textContent = '??:??'; }
            p.appendChild(nameSpan);
            p.appendChild(msgSpan);
            p.appendChild(timeSpan);
            fragment.appendChild(p);
        });
        DOMElements.chatMessages.appendChild(fragment);
        if (shouldScroll) {
            DOMElements.chatMessages.scrollTop = DOMElements.chatMessages.scrollHeight;
        }
    },

    // --- UI Mode & Reset ---
    toggleUIMode: () => {
        AppState.isComputerUI = !AppState.isComputerUI;
        DOMElements.body.classList.toggle('computer-ui', AppState.isComputerUI);
        DOMElements.toggleUIButton.textContent = AppState.isComputerUI ? "Switch to Mobile UI" : "Switch to Computer UI";
        Utils.log('info', `UI Mode switched to: ${AppState.isComputerUI ? 'Computer' : 'Mobile'}`);
    },

    resetUIForLogout: () => {
        UI.showScreen('loginScreen');
        if (DOMElements.loginForm) DOMElements.loginForm.reset();
        Utils.hideElement(DOMElements.displayNameInput);
        if (DOMElements.loginForm) Utils.enableButton(DOMElements.loginForm.querySelector('button[type="submit"]'));
        if (DOMElements.leaderboardListUl) DOMElements.leaderboardListUl.innerHTML = '';
        if (DOMElements.chatMessages) DOMElements.chatMessages.innerHTML = '<p>Please log in to chat.</p>';
        // Reset other dynamic areas if needed
        if (DOMElements.inventoryListUl) DOMElements.inventoryListUl.innerHTML = '';
        if (DOMElements.deckListUl) DOMElements.deckListUl.innerHTML = '';
        if (DOMElements.appraisalListUl) DOMElements.appraisalListUl.innerHTML = '';
        if (DOMElements.turnLogDiv) DOMElements.turnLogDiv.innerHTML = '';
        if (DOMElements.rollResultDiv) DOMElements.rollResultDiv.innerHTML = '';
        Utils.setInactive(DOMElements.rollResultDiv);
        Utils.hideElement(DOMElements.flipCardBtn);
        if (DOMElements.caseResultDiv) DOMElements.caseResultDiv.innerHTML = '';
        Utils.setInactive(DOMElements.caseResultDiv);
        UI.showTab('roll'); // Default to roll tab on logout
    },

    // --- Animations & Popups ---
    startAppraisalAnimation: () => {
        if (!DOMElements.appraisalOverlay || !DOMElements.appraisalCircle || !DOMElements.appraisalPopup) return;
        Utils.setInactive(DOMElements.appraisalPopup);
        DOMElements.appraisalPopupMessage.innerHTML = '';
        DOMElements.appraisalCircle.style.transition = 'none';
        DOMElements.appraisalCircle.style.transform = 'scale(0)';
        DOMElements.appraisalCircle.offsetHeight; // Trigger reflow
        Utils.setActive(DOMElements.appraisalOverlay);
        DOMElements.appraisalCircle.style.transition = 'transform 1.5s cubic-bezier(0.25, 1, 0.5, 1)';
        requestAnimationFrame(() => {
            DOMElements.appraisalCircle.style.transform = 'scale(200)';
        });
    },

    endAppraisalAnimation: (popupMessages) => {
        if (!DOMElements.appraisalOverlay || !DOMElements.appraisalCircle || !DOMElements.appraisalPopup) return;
        setTimeout(() => {
            Utils.setInactive(DOMElements.appraisalOverlay);
            setTimeout(() => {
                DOMElements.appraisalCircle.style.transition = 'none';
                DOMElements.appraisalCircle.style.transform = 'scale(0)';
            }, 300); // Let fade out finish
            DOMElements.appraisalPopupMessage.innerHTML = popupMessages;
            Utils.setActive(DOMElements.appraisalPopup);
        }, 1600); // After animation duration + buffer
    },

    closeAppraisalPopup: () => {
        if (DOMElements.appraisalPopup) Utils.setInactive(DOMElements.appraisalPopup);
    },

    startCaseOpeningAnimation: (animationItems, winningCard, callback, callbackDelay = 3600) => { // Added delay parameter with default
        if (!DOMElements.caseAnimationDiv || !DOMElements.caseResultDiv || !DOMElements.caseAnimationWrapper) return;
        DOMElements.caseAnimationDiv.innerHTML = ''; // Clear previous items
        DOMElements.caseResultDiv.innerHTML = '';
        Utils.setInactive(DOMElements.caseResultDiv);

        // Add items to DOM
        const fragment = document.createDocumentFragment();
        animationItems.forEach(item => {
            const itemDiv = document.createElement('div');
            itemDiv.classList.add('item');
            itemDiv.innerHTML = `<span style="color:${item?.color || '#FFF'}">${item?.name || '?'}</span><br>(${Utils.capitalize(item?.rarity || '?')})`;
            fragment.appendChild(itemDiv);
        });
        DOMElements.caseAnimationDiv.appendChild(fragment);

        // --- Use requestAnimationFrame for measurements and animation start ---
        requestAnimationFrame(() => {
            const targetItemIndex = animationItems.findIndex(item => item?.id === winningCard?.id);
            if (targetItemIndex === -1) {
                 Utils.log('error', "[RAF] Winning card ID not found in generated animation reel!");
                 return; // Stop if winner cannot be located
             }

            const children = DOMElements.caseAnimationDiv.children;
            let winnerDiv = children.length > targetItemIndex ? children[targetItemIndex] : null;
            if (winnerDiv) winnerDiv.dataset.isWinner = "true";

            // Measure widths *after* elements are in the DOM and styled (within RAF)
            const containerWidth = DOMElements.caseAnimationWrapper.offsetWidth;
            const itemWidth = children.length > 0 ? children[0].offsetWidth : 120; // Measure first item, fallback

            if (itemWidth === 0) {
                Utils.log('warn', "[RAF] Measured item width is 0. Using fallback 120px.");
            }
             // --- Enhanced Logging ---
            Utils.log('debug', `[Animation Start] Container W: ${containerWidth}, Item W: ${itemWidth}, Target Index: ${targetItemIndex}`);


            // --- Recalculate Final Position (Stop 2 cards later) ---
            // Original centering: -(targetItemIndex * itemWidth) + (containerWidth / 2) - (itemWidth / 2);
            const finalPosition = -((targetItemIndex + 2) * itemWidth) + (containerWidth / 2) - (itemWidth / 2);
            Utils.log('debug', `[Animation Start] Calculated Final Position (Target+2): ${finalPosition}`);


            // --- Apply Animation ---
            DOMElements.caseAnimationDiv.style.transition = 'none'; // Reset transition before positioning
            DOMElements.caseAnimationDiv.style.transform = 'translateX(0px)'; // Go to start
            DOMElements.caseAnimationDiv.offsetHeight; // Force reflow

            // Apply the actual transition and final transform
            DOMElements.caseAnimationDiv.style.transition = 'transform 3.5s cubic-bezier(0.33, 1, 0.68, 1)';
            DOMElements.caseAnimationDiv.style.transform = `translateX(${finalPosition}px)`;

            // --- Setup Callback ---
            const jsTimeoutDelay = 3600; // Align with CSS + buffer

            setTimeout(() => {
                if (winnerDiv) {
                    winnerDiv.style.border = "2px solid gold";
                    winnerDiv.style.boxShadow = "0 0 15px gold";
                }
                if (callback) callback();

                setTimeout(() => {
                    if (winnerDiv) {
                        winnerDiv.style.border = "";
                        winnerDiv.style.boxShadow = "";
                    }
                }, 1500);
            }, jsTimeoutDelay);
        }); // --- End of requestAnimationFrame ---
    },

    displayRollResult: (item) => {
        if (!DOMElements.rollResultDiv || !DOMElements.flipCardBtn) return;

        if (!item) {
            // Clear the display if item is null/undefined
            DOMElements.rollResultDiv.innerHTML = '';
            DOMElements.rollResultDiv.classList.remove('visible'); // Ensure hidden
            Utils.hideElement(DOMElements.flipCardBtn);
            return;
        }

        // Construct and display the card HTML
        DOMElements.rollResultDiv.innerHTML = `
                             <div class="card" id="rolledCard">
                                 <div class="card-inner">
                                     <div class="card-front">
                                         <strong style="color:${item.color || '#FFF'}; font-size: 1.2em;">${item.name}</strong><br>
                                         (${Utils.capitalize(item.rarity)})<br>
                                         <hr>
                                         Grade: ${item.grade}, Quality: ${item.quality}<br>
                                         Stats: ATK ${item.attack} / DEF ${item.defense}<br>
                                         Value: ${item.value} Coins
                                     </div>
                                     <div class="card-back">
                                         <strong>Ability:</strong><br>
                                         ${item.ability?.description || 'None'}
                                     </div>
                                 </div>
                             </div>
                         `;

        // Visibility is controlled by the .visible class added in Roll.handleRollClick
        // No need for Utils.setActive(DOMElements.rollResultDiv); here

        Utils.showElement(DOMElements.flipCardBtn);

        // --- Attach flip listener directly after creating the card ---
        const cardElement = document.getElementById('rolledCard'); // Get the newly added card element
        if (cardElement) {
            // Assign the click handler directly to the button
             DOMElements.flipCardBtn.onclick = () => {
                 cardElement.classList.toggle("flipped");
             };
        } else {
             // Safety net: If the card element isn't found, disable the button's click
             Utils.log('warn', 'Rolled card element not found immediately after creation.');
             DOMElements.flipCardBtn.onclick = null;
        }
        // --- End flip listener attachment ---
    },

    // --- Initial Population ---
    _staticDataPopulated: false,
    populateStaticDataOnce: () => {
        if (UI._staticDataPopulated) return;
        Utils.log('info', "Populating static UI data (rarity lists, filters)...");

        const rarityFilterFragment = document.createDocumentFragment();
        const deckFilterFragment = document.createDocumentFragment();
        const oddsListFragment = document.createDocumentFragment();

        const allOption1 = document.createElement('option'); allOption1.value = ""; allOption1.textContent = "All Rarities";
        rarityFilterFragment.appendChild(allOption1);
        const allOption2 = document.createElement('option'); allOption2.value = ""; allOption2.textContent = "All Rarities";
        deckFilterFragment.appendChild(allOption2);

        Constants.RARITIES.forEach(r => {
            const option = document.createElement('option'); option.value = r.name; option.textContent = Utils.capitalize(r.name);
            rarityFilterFragment.appendChild(option.cloneNode(true));
            deckFilterFragment.appendChild(option.cloneNode(true));
            const li = document.createElement('li'); li.innerHTML = `<span style="color:${r.color};">${Utils.capitalize(r.name)}</span> (${r.prob}%)`;
            oddsListFragment.appendChild(li);
        });

        if (DOMElements.rarityFilterSelect) { DOMElements.rarityFilterSelect.innerHTML = ''; DOMElements.rarityFilterSelect.appendChild(rarityFilterFragment); }
        if (DOMElements.deckRarityFilterSelect) { DOMElements.deckRarityFilterSelect.innerHTML = ''; DOMElements.deckRarityFilterSelect.appendChild(deckFilterFragment); }
        if (DOMElements.rarityRolledListUl) { DOMElements.rarityRolledListUl.innerHTML = ''; DOMElements.rarityRolledListUl.appendChild(oddsListFragment); }

        UI._staticDataPopulated = true;
    },

    updateBattleUI: () => {
        if (!AppState.currentBattleState || !DOMElements.turnLogDiv) return;
        DOMElements.turnLogDiv.innerHTML = AppState.currentBattleState.turnLog.join('\n');
        DOMElements.turnLogDiv.scrollTop = DOMElements.turnLogDiv.scrollHeight;
    },

}; // End UI Module

// --- Game Logic Module (Calculations, Card Generation) ---
const GameLogic = {
    calculateTotalPower: () => {
        if (!AppState.userData) return 0;
        let total = AppState.userData.playerScore || 0;
        (AppState.userData.inventory || []).forEach(card => {
            total += (card?.attack || 0) + (card?.defense || 0);
        });
        return total;
    },

    calculateLuckBonusPercentage: () => {
        if (!AppState.userData) return 0;
        const levelBonus = (AppState.userData.luckLevel || 0) * 2;
        const potionBonus = AppState.activeBoosts.luck.active ? 10 : 0;
        const exclusivePotionBonus = AppState.activeBoosts.exclusiveLuck.active ? Constants.EXCLUSIVE_LUCK_POTION_BONUS : 0;
        return levelBonus + potionBonus + exclusivePotionBonus;
    },

    calculateCurrentCooldown: () => {
        if (!AppState.userData) return Constants.BASE_COOLDOWN_MS;
        let currentCooldown = Math.max(
            Constants.BASE_COOLDOWN_MS - (AppState.userData.cooldownLevel || 0) * Constants.COOLDOWN_REDUCTION_MS,
            Constants.MIN_COOLDOWN_MS
        );
        if (AppState.activeBoosts.speed.active) {
            currentCooldown = Math.max(currentCooldown * 0.7, Constants.MIN_COOLDOWN_MS);
        }
        return currentCooldown;
    },

    generateRandomAbility: () => {
        const effects = ["Heal", "Damage Boost", "Defense Buff", "Crit Chance", "Cooldown Reduction", "Life Steal"];
        const targets = ["self", "enemy", "random ally"];
        const triggers = ["On Play", "Start of Turn", "On Attack", "On Defeat"];
        const value = Utils.getRandomInt(5, 25);
        const duration = Utils.getRandomInt(1, 3);
        const effect = effects[Utils.getRandomInt(0, effects.length - 1)];
        const target = targets[Utils.getRandomInt(0, targets.length - 1)];
        const trigger = triggers[Utils.getRandomInt(0, triggers.length - 1)];

        return {
            description: `${effect} ${value} on ${target} (${trigger}, ${duration} turns)`,
            effect: effect, value: value, target: target, trigger: trigger, duration: duration
        };
    },

    generateCard: (rarityName, cardIdNumber) => { // Accept cardIdNumber
        const rarityData = Constants.RARITIES.find(r => r.name === rarityName);
        if (!rarityData) {
            Utils.log('warn', `Invalid rarity provided to generateCard: ${rarityName}.`);
            return null; // Return null for invalid rarity
        }

        // Validate the cardIdNumber from Firestore
        if (typeof cardIdNumber !== 'number' || cardIdNumber <= 0) {
             Utils.log('error', 'Invalid cardIdNumber received for card generation:', cardIdNumber);
             return null; // Cannot generate without a valid ID
        }

        const grade = Constants.GRADES[Utils.getRandomInt(0, Constants.GRADES.length - 1)];
        const quality = Constants.QUALITIES[Utils.getRandomInt(0, Constants.QUALITIES.length - 1)];
        const baseAttack = Utils.getRandomInt(rarityData.stats.min, rarityData.stats.max);
        const baseDefense = Utils.getRandomInt(rarityData.stats.min, rarityData.stats.max);

        const gradeMultiplier = Constants.GRADE_MULTIPLIERS[grade] || 1.0;
        const qualityMultiplier = Constants.QUALITY_MULTIPLIERS[quality] || 1.0;

        const attack = Math.max(1, Math.floor(baseAttack * gradeMultiplier * qualityMultiplier));
        const defense = Math.max(1, Math.floor(baseDefense * gradeMultiplier * qualityMultiplier));
        const value = Math.max(1, Math.floor(rarityData.value * gradeMultiplier * qualityMultiplier));

        // Construct the unique ID using the number from the Firestore counter
        const uniqueId = `card-${AppState.currentUserId?.substring(0, 5) || 'nouser'}-${cardIdNumber}`;

        // Remove the old localStorage counter logic
        // AppState.globalCardIdCounter++; // REMOVED
        // localStorage.setItem("globalCardIdCounter_v2", AppState.globalCardIdCounter.toString()); // REMOVED

        return {
            id: uniqueId, // Use the ID derived from Firestore counter
            name: `${Utils.capitalize(rarityName)} Card #${Utils.getRandomInt(1, 100)}`,
            value: value,
            description: `A ${rarityName} card. Grade: ${grade}, Quality: ${quality}.`,
            ability: GameLogic.generateRandomAbility(),
            attack: attack,
            defense: defense,
            rarity: rarityName,
            grade: grade,
            quality: quality,
            color: rarityData.color
        };
    },

    chooseRarityWeighted: () => {
        const totalWeight = Constants.RARITIES.reduce((sum, r) => sum + (r.prob || 0), 0);
        if (totalWeight <= 0) return Constants.RARITIES[0].name;

        const luckMultiplier = 1 + (GameLogic.calculateLuckBonusPercentage() / 100);
        let adjustedTotalWeight = 0;
        const weightedRarities = Constants.RARITIES.map(r => {
            const weight = (r.prob || 0) * luckMultiplier;
            adjustedTotalWeight += weight;
            return { name: r.name, weight: weight };
        });

        if (adjustedTotalWeight <= 0) return Constants.RARITIES[0].name;

        let rollRandom = Math.random() * adjustedTotalWeight;
        let chosenRarityName = Constants.RARITIES[0].name;

        for (const rarity of weightedRarities) {
            if (rollRandom <= rarity.weight) {
                chosenRarityName = rarity.name;
                break;
            }
            rollRandom -= rarity.weight;
        }
        return chosenRarityName;
    },

    chooseCaseRarityWeighted: (caseDropRates) => {
        const totalWeight = Object.values(caseDropRates).reduce((sum, prob) => sum + (prob || 0), 0);
        if (totalWeight <= 0) return Constants.RARITIES[0].name;

        const rollRandom = Math.random() * totalWeight;
        let selectedRarity = "";
        let cumulativeWeight = 0;

        for (const [rarityName, weight] of Object.entries(caseDropRates)) {
            cumulativeWeight += weight;
            if (rollRandom < cumulativeWeight) {
                selectedRarity = rarityName;
                break;
            }
        }
        return selectedRarity;
    },
}; // End GameLogic Module

// --- Roll Module ---
const Roll = {
    initialize: () => {
        Utils.addListener(DOMElements.rollButton, 'click', Roll.handleRollClick);
    },

    handleRollClick: async () => { // Made async
        if (AppState.isRolling || !AppState.currentUserId || !AppState.userData) return;

        AppState.isRolling = true; // Set rolling flag
        Utils.disableButton(DOMElements.rollButton);
        if (DOMElements.rollResultDiv) {
            DOMElements.rollResultDiv.innerHTML = '<p>Rolling...</p>';
            // Remove 'visible' immediately to hide any previous result during roll
            DOMElements.rollResultDiv.classList.remove('visible');
        }
        Utils.hideElement(DOMElements.flipCardBtn);

        const chosenRarityName = GameLogic.chooseRarityWeighted();
        Utils.log('info', `Rolled rarity: ${chosenRarityName}`);

        // Use a transaction to get the next card ID
        const db = AppState.db;
        const counterRef = db.collection('counters').doc('cardCounter');
        let newCard = null;

        try {
            // Transaction to read and increment the counter
            const nextId = await db.runTransaction(async (transaction) => {
                const counterDoc = await transaction.get(counterRef);
                if (!counterDoc.exists) {
                    // Throw an error if the counter document doesn't exist
                    // User needs to create 'counters/cardCounter' with a 'count' field (number)
                    throw "Counter document ('counters/cardCounter') not found in Firestore!";
                }
                const newCount = (counterDoc.data()?.count || 0) + 1; // Safely access count
                transaction.update(counterRef, { count: newCount });
                return newCount; // Return the new ID number
            });

            Utils.log('info', `Next card ID from Firestore: ${nextId}`);
            // Generate the card using the new ID number
            newCard = GameLogic.generateCard(chosenRarityName, nextId);

            // Check if card generation was successful
            if (!newCard) {
                 throw new Error("Card generation failed (invalid rarity or ID).");
            }

            // Save the newly generated card to the user's inventory
            await Firestore.addUserArrayItem('inventory', newCard);
            Utils.log('info', `Card ${newCard.id} added to inventory.`);

            // Update UI AFTER successful save
            UI.displayRollResult(newCard);
            if (DOMElements.rollResultDiv) {
                // Add 'visible' class to trigger the fade-in effect
                DOMElements.rollResultDiv.classList.add('visible');
            }
            Roll.startCooldown(); // Start cooldown only after success

        } catch (error) {
            // Handle errors from transaction, card generation, or saving
            Utils.log('error', "Failed during card roll process:", error);
            alert(`Roll Failed: ${error.message || error}`); // Show specific error message

            // Reset UI state on failure
            AppState.isRolling = false;
            Utils.enableButton(DOMElements.rollButton);
            if (DOMElements.rollResultDiv) {
                DOMElements.rollResultDiv.innerHTML = ''; // Clear rolling message
                DOMElements.rollResultDiv.classList.remove('visible'); // Ensure it's hidden
            }
             Utils.hideElement(DOMElements.flipCardBtn);
        }
        // Note: AppState.isRolling is reset inside startCooldown on success,
        // and in the catch block on failure.
    },

    startCooldown: () => {
        const cooldownMs = GameLogic.calculateCurrentCooldown();
        let endTime = Date.now() + cooldownMs;
        // Button is already disabled from handleRollClick

        if (AppState.rollCooldownTimer) clearInterval(AppState.rollCooldownTimer);

        const updateTimerDisplay = () => {
            const remainingMs = Math.max(0, endTime - Date.now());
            if (DOMElements.cooldownTimerP) {
                DOMElements.cooldownTimerP.textContent = remainingMs > 0
                    ? `Cooldown: ${Utils.formatTimeRemaining(remainingMs)}`
                    : ""; // Clear text when ready
            }
            if (remainingMs <= 0) {
                clearInterval(AppState.rollCooldownTimer);
                AppState.rollCooldownTimer = null;
                Utils.enableButton(DOMElements.rollButton); // Re-enable button
                AppState.isRolling = false; // Reset rolling flag AFTER cooldown
            }
        };
        updateTimerDisplay(); // Initial display

        AppState.rollCooldownTimer = setInterval(updateTimerDisplay, 100);
        // Reset rolling flag AFTER cooldown finishes in updateTimerDisplay
        // AppState.isRolling = false; // REMOVED from here
    },

    updateCooldownDisplay: () => {
        const currentCooldownMs = GameLogic.calculateCurrentCooldown();
        if (DOMElements.currentCooldownP) {
            DOMElements.currentCooldownP.textContent = `Roll Cooldown: ${(currentCooldownMs / 1000).toFixed(1)}s`;
        }
    },
    updateLuckBonusDisplay: () => {
        const luckPercent = GameLogic.calculateLuckBonusPercentage();
        const luckDisplayText = `Luck Bonus: +${luckPercent}%`;
        if (DOMElements.rollLuckDisplayP) DOMElements.rollLuckDisplayP.textContent = luckDisplayText;
        if (DOMElements.upgradeLuckDisplayP) DOMElements.upgradeLuckDisplayP.textContent = luckDisplayText;
    }
}; // End Roll Module

// --- Inventory Module ---
const Inventory = {
    initialize: () => {
        Utils.addListener(DOMElements.sellDuplicatesBtn, 'click', () => Inventory.sellDuplicateCards('uncommon'));
        Utils.addListener(DOMElements.inventoryListUl, 'click', Inventory.handleListClick);
    },

    handleListClick: (event) => {
        const button = event.target.closest('button[data-action="sell"]');
        if (!button) return;
        const listItem = button.closest('li[data-card-id]');
        if (listItem) Inventory.sellItem(listItem.dataset.cardId);
    },

    updateList: () => {
        const selectedRarity = DOMElements.rarityFilterSelect?.value;
        const inventory = AppState.userData?.inventory || [];
        const filteredItems = selectedRarity ? inventory.filter(card => card?.rarity === selectedRarity) : inventory;

        if (DOMElements.inventoryCountSpan) DOMElements.inventoryCountSpan.textContent = inventory.length;

        UI.renderList(
            DOMElements.inventoryListUl,
            filteredItems,
            (card) => UI.createCardListItem(card, [{ text: 'Sell', class: 'btn-secondary' }]),
            selectedRarity ? "No cards match filter." : "Inventory empty."
        );
    },

    sellItem: async (cardId) => {
        const inventory = AppState.userData?.inventory;
        if (!inventory) return;
        const cardIndex = inventory.findIndex(item => item?.id === cardId);
        if (cardIndex === -1) return;

        const item = inventory[cardIndex];
        const rarityIndex = Constants.RARITIES.findIndex(r => r.name === item.rarity);
        const eternalIndex = Constants.RARITIES.findIndex(r => r.name === 'eternal');
        const isValuable = rarityIndex >= Constants.RARITIES.findIndex(r => r.name === 'rare');
        const isExtremelyValuable = eternalIndex !== -1 && rarityIndex >= eternalIndex;

        let confirmSell = true;
        if (isExtremelyValuable) confirmSell = confirm(`ARE YOU SURE?\nSell ${item.name} (${Utils.capitalize(item.rarity)}) for ${item.value} coins?\nThis is extremely valuable!`);
        else if (isValuable) confirmSell = confirm(`Sell ${item.name} (${Utils.capitalize(item.rarity)}) for ${item.value} coins?`);
        if (!confirmSell) return;

        const updates = {
            currency: firebase.firestore.FieldValue.increment(item.value || 0),
            playerScore: firebase.firestore.FieldValue.increment(Math.floor((item.value || 0) / Constants.SELL_DUPLICATE_SCORE_DIVISOR))
        };

        try {
            await Firestore.updateUserData(updates);
            await Firestore.removeUserArrayItem('inventory', item); // Remove using the item object
            Deck.removeFromDeckLocal(cardId); // Update local deck if needed
            Utils.log('info', `Sold item ${cardId}.`);
        } catch (error) {
            Utils.log('error', "Sell item failed:", error); alert("Failed to sell item.");
        }
    },

    sellDuplicateCards: async (rarityThresholdName = "uncommon") => {
        const inventory = AppState.userData?.inventory;
        if (!inventory || inventory.length === 0) { alert("Inventory empty."); return; }
        const thresholdIndex = Constants.RARITIES.findIndex(r => r.name === rarityThresholdName);
        if (thresholdIndex === -1) return; // Invalid threshold

        const cardsToSell = [];
        const cardsToKeep = [];
        const keptCardSignatures = new Set(); // Use name to identify duplicates for selling
        let totalValue = 0;
        let scoreToAdd = 0;

        // Separate higher rarities (won't be sold as duplicates)
        const highRarityCards = inventory.filter(card => Constants.RARITIES.findIndex(r => r.name === card.rarity) > thresholdIndex);
        // Process only cards at or below the threshold
        const processableCards = inventory.filter(card => Constants.RARITIES.findIndex(r => r.name === card.rarity) <= thresholdIndex);
        // Sort processable cards to keep the 'best' (highest value) duplicate
        processableCards.sort((a, b) => (b.value || 0) - (a.value || 0) || (a.id || '').localeCompare(b.id || ''));

        // Iterate and decide which cards to keep vs sell
        for (const card of processableCards) {
            if (!keptCardSignatures.has(card.name)) {
                // First occurrence of this card name, keep it
                cardsToKeep.push(card);
                keptCardSignatures.add(card.name);
            } else {
                // Duplicate found, mark for selling
                cardsToSell.push(card);
            }
        }

        if (cardsToSell.length === 0) { alert(`No duplicate ${Utils.capitalize(rarityThresholdName)} or lower rarity cards found.`); return; }

        // Calculate totals and update local deck state
        cardsToSell.forEach(card => {
            totalValue += card.value || 0;
            scoreToAdd += Math.floor((card.value || 0) / Constants.SELL_DUPLICATE_SCORE_DIVISOR);
            Deck.removeFromDeckLocal(card.id); // Ensure sold cards are removed from deck
        });

        // Construct final inventory and updates
        const finalInventory = [...cardsToKeep, ...highRarityCards]; // Combine kept low rarities and all high rarities
        const updates = {
            inventory: finalInventory, // Overwrite inventory with the filtered list
            currency: firebase.firestore.FieldValue.increment(totalValue),
            playerScore: firebase.firestore.FieldValue.increment(scoreToAdd)
        };

        try {
            await Firestore.updateUserData(updates); // Single update to Firestore
            Utils.log('info', `Sold ${cardsToSell.length} duplicates.`);
            alert(`Sold ${cardsToSell.length} duplicate card(s) for ${totalValue} coins, gained ${scoreToAdd} score.`);
        } catch (error) {
            Utils.log('error', "Sell duplicates failed:", error); alert("Failed to sell duplicates.");
        }
    }
}; // End Inventory Module

// --- Deck Module ---
const Deck = {
    initialize: () => {
        Utils.addListener(DOMElements.deckInventoryListUl, 'click', Deck.handleAvailableListClick);
        Utils.addListener(DOMElements.deckListUl, 'click', Deck.handleCurrentDeckClick);
    },

    handleAvailableListClick: (event) => {
        Utils.log('debug', '[Deck.handleAvailableListClick] Click detected on available list.', event.target);
        const button = event.target.closest('button[data-action="add-to-deck"]');
        Utils.log('debug', '[Deck.handleAvailableListClick] Found button:', button);
        if (!button) return;
        const listItem = button.closest('li[data-card-id]');
        Utils.log('debug', '[Deck.handleAvailableListClick] Found list item:', listItem);
        if (listItem) {
             Utils.log('debug', '[Deck.handleAvailableListClick] Calling addToDeck with ID:', listItem.dataset.cardId);
            Deck.addToDeck(listItem.dataset.cardId);
        }
    },

    handleCurrentDeckClick: (event) => {
        const button = event.target.closest('button[data-action="remove"]');
        if (!button) return;
        const listItem = button.closest('li[data-card-id]');
        if (listItem) Deck.removeFromDeck(listItem.dataset.cardId);
    },

    updateLists: () => {
        Utils.log('debug', '[Deck.updateLists] STARTING UI Update'); // <-- DEBUG LOG
        const deck = AppState.userData?.deck || [];
        const inventory = AppState.userData?.inventory || [];
        Utils.log('debug', `[Deck.updateLists] Deck length: ${deck.length}, Inventory length: ${inventory.length}`); // <-- DEBUG LOG
        const selectedDeckRarity = DOMElements.deckRarityFilterSelect?.value;
        const deckCardIds = new Set(deck.map(card => card?.id).filter(id => id)); // Get IDs of cards currently in deck
        const deckIsFull = deck.length >= Constants.DECK_SIZE_LIMIT;

        // Render current deck
        UI.renderList(
            DOMElements.deckListUl,
            deck,
            (card) => UI.createCardListItem(card, [{ text: 'Remove', class: 'btn-secondary' }]),
            "Deck is empty."
        );

        // Render available cards (inventory minus deck cards, optionally filtered)
        let availableItems = inventory.filter(card => card && !deckCardIds.has(card.id));
        if (selectedDeckRarity) availableItems = availableItems.filter(card => card.rarity === selectedDeckRarity);

        UI.renderList(
            DOMElements.deckInventoryListUl,
            availableItems,
            (card) => UI.createCardListItem(card, [{ text: 'Add to Deck', disabled: deckIsFull, class: 'btn-primary' }]),
            selectedDeckRarity ? "No cards match filter." : "No available cards."
        );

        // Update counts
        if (DOMElements.deckCountSpan) DOMElements.deckCountSpan.textContent = deck.length;
        if (DOMElements.deckPowerSpan) DOMElements.deckPowerSpan.textContent = Deck.calculateDeckPower();
    },

    addToDeck: async (cardId) => {
        const deck = AppState.userData?.deck || [];
        const inventory = AppState.userData?.inventory || [];
        if (deck.length >= Constants.DECK_SIZE_LIMIT) { alert(`Deck full.`); return; }
        const card = inventory.find(item => item?.id === cardId);
        if (!card) { alert("Card not found."); return; }
        // Check if card is *already* in the deck
        if (deck.some(c => c?.id === cardId)) return; // Already there, do nothing

        Utils.log('debug', '[Deck.addToDeck] Attempting Firestore update with card:', JSON.stringify(card)); // <-- DEBUG LOG
        try {
            await Firestore.addUserArrayItem('deck', card);
            Utils.log('info', `[Deck.addToDeck] Added ${cardId} to deck via Firestore. Waiting for listener...`); // <-- DEBUG LOG
            // Snapshot listener will trigger UI update
        } catch (error) {
            Utils.log('error', "Add to deck failed:", error); alert("Failed to add to deck.");
        }
    },

    removeFromDeck: async (cardId) => {
        const deck = AppState.userData?.deck || [];
        const cardToRemove = deck.find(c => c?.id === cardId);
        if (!cardToRemove) return; // Card not in deck
        try {
            await Firestore.removeUserArrayItem('deck', cardToRemove);
            Utils.log('info', `Removed ${cardId} from deck.`);
            // Snapshot listener will trigger UI update
        } catch (error) {
            Utils.log('error', "Remove from deck failed:", error); alert("Failed to remove from deck.");
        }
    },

    removeFromDeckLocal: (cardId) => {
        // Used when selling items that might be in the deck, avoids waiting for Firestore echo
        if (!AppState.userData?.deck) return;
        const initialLength = AppState.userData.deck.length;
        AppState.userData.deck = AppState.userData.deck.filter(card => card?.id !== cardId);
        if (AppState.userData.deck.length < initialLength) { // Check if a card was actually removed
            Utils.log('info', `Card ${cardId} removed from local deck cache.`);
            Deck.updateLists(); // Update UI immediately
        }
    },

    calculateDeckPower: () => {
        const deck = AppState.userData?.deck || [];
        return deck.reduce((sum, card) => sum + (card?.attack || 0) + (card?.defense || 0), 0);
    }
}
// --- Appraisal Module ---
const Appraisal = {
    initialize: () => {
        // Setup listener for appraise button clicks
        Utils.addListener(DOMElements.appraisalListUl, 'click', Appraisal.handleListClick);
    },

    handleListClick: (event) => {
        // Identify the appraise button that was clicked
        const button = event.target.closest('button[data-action="appraise"]');
        if (!button) return; // Exit if no valid button
        const listItem = button.closest('li[data-card-id]');
        if (listItem) Appraisal.appraiseCard(listItem.dataset.cardId); // Call appraiseCard with the card ID
    },

    updateList: () => {
        const inventory = AppState.userData?.inventory || [];
        const canAfford = (AppState.userData?.currency || 0) >= Constants.APPRAISAL_COST; // Check if user can afford appraisal

        // Render the list of cards available for appraisal
        UI.renderList(
            DOMElements.appraisalListUl,
            inventory,
            (card) => UI.createCardListItem(card, [
                { text: `Appraise (${Constants.APPRAISAL_COST})`, disabled: !canAfford, class: 'btn-primary' }
            ]),
            "No cards to appraise."
        );
    },

    appraiseCard: async (cardId) => {
        const currentInventory = [...(AppState.userData?.inventory || [])];
        const cardIndex = currentInventory.findIndex(item => item?.id === cardId);
            UI.startAppraisalAnimation();

        // Ensure the card exists in inventory
        if (cardIndex === -1) {
            alert("Card not found in inventory.");
            return; 
        }

        // Check if the user has enough currency
        if ((AppState.userData?.currency || 0) < Constants.APPRAISAL_COST) {
            alert(`You need ${Constants.APPRAISAL_COST} coins to appraise this card.`);
            return; 
        }

        const card = currentInventory[cardIndex]; // Get the card object

        // Prepare appraisal data
        let messages = [];
        const oldValue = card.value; // Store old value for later display
        messages.push(`<p>Appraisal Cost: ${Constants.APPRAISAL_COST} coins.</p>`); // Include appraisal cost message
        
        // Update card value based on appraisal
        card.value = Math.floor(card.value * Constants.APPRAISAL_VALUE_MULTIPLIER); // Adjust value

        // Build initial appraisal result message
        messages.push(`<p><strong>${card.name}</strong> value: ${oldValue} -> ${card.value}.</p>`); // Show value change

        // Handle potential upgrades to card's grade and quality
        const oldGrade = card.grade;
        const oldQuality = card.quality;
        let gradeUpgraded = false;
        let qualityUpgraded = false;

        // Grade Upgrade Check
        const currentGradeIndex = Constants.GRADES.indexOf(card.grade);
        if (currentGradeIndex >= 0 && currentGradeIndex < Constants.GRADES.length - 1 && Math.random() < Constants.GRADE_UPGRADE_CHANCE) {
            card.grade = Constants.GRADES[currentGradeIndex + 1];
            messages.push(`<p style="color: var(--success-color);">Grade: ${oldGrade} -> ${card.grade}!</p>`); // Grade change message
            gradeUpgraded = true;
        }

        // Quality Upgrade Check
        const currentQualityIndex = Constants.QUALITIES.indexOf(card.quality);
        if (currentQualityIndex >= 0 && currentQualityIndex < Constants.QUALITIES.length - 1 && Math.random() < Constants.QUALITY_UPGRADE_CHANCE) {
            card.quality = Constants.QUALITIES[currentQualityIndex + 1];
            messages.push(`<p style="color: var(--success-color);">Quality: ${oldQuality} -> ${card.quality}!</p>`); // Quality change message
            qualityUpgraded = true;
        }

        if (!gradeUpgraded && !qualityUpgraded) {
            messages.push("<p>Grade and Quality remain unchanged.</p>"); // Message if nothing changes
        }

        // Re-roll stats based on new grade/quality
        const rarityData = Constants.RARITIES.find(r => r.name === card.rarity);
        if (rarityData) {
            const baseAttack = Utils.getRandomInt(rarityData.stats.min, rarityData.stats.max);
            const baseDefense = Utils.getRandomInt(rarityData.stats.min, rarityData.stats.max);
            const gradeMultiplier = Constants.GRADE_MULTIPLIERS[card.grade] || 1.0;
            const qualityMultiplier = Constants.QUALITY_MULTIPLIERS[card.quality] || 1.0;

            card.attack = Math.max(1, Math.floor(baseAttack * gradeMultiplier * qualityMultiplier));
            card.defense = Math.max(1, Math.floor(baseDefense * gradeMultiplier * qualityMultiplier));
            messages.push(`<p>New Stats: ATK ${card.attack}, DEF ${card.defense}.</p>`); // Show new stats
        }

        // Prepare updates for Firestore and remove coins
        const updates = {
            inventory: currentInventory, // Updated inventory
            currency: firebase.firestore.FieldValue.increment(-Constants.APPRAISAL_COST) // Deduct coins
        };
        
        try {
            await Firestore.updateUserData(updates); // Update Firestore
            Utils.log('info', `Successfully appraised ${cardId}.`);
            document.getElementById('appraisalPopupMessage').innerHTML = messages.join(""); // Show results in popup
            document.getElementById('appraisalPopup').style.display = 'block'; // Display popup with results
            const popupMessages = messages.join('');
            UI.endAppraisalAnimation(popupMessages);
        }catch (error){ 
        Utils.log('error', "Appraisal failed:", error);
        UI.endAppraisalAnimation(`<p style="color: red;">Appraisal failed: ${error.message}</p>`); {
            // Hide overlay
            if (DOMElements.appraisalListUl) Appraisal.updateList(); // Refresh the list
        }
        }
    }
}; // End Appraisal Module
// --- Upgrades Module ---
const Upgrades = {
    initialize: () => {
        Utils.addListener(DOMElements.upgradeCooldownBtn, 'click', Upgrades.upgradeCooldown);
        Utils.addListener(DOMElements.upgradeLuckBtn, 'click', Upgrades.upgradeLuck);
        Utils.addListener(DOMElements.buyLuckPotionBtn, 'click', () => Upgrades.buyPotion('luck', 100));
        Utils.addListener(DOMElements.useLuckPotionBtn, 'click', () => Upgrades.usePotion('luck'));
        Utils.addListener(DOMElements.buySpeedPotionBtn, 'click', () => Upgrades.buyPotion('speed', 120));
        Utils.addListener(DOMElements.useSpeedPotionBtn, 'click', () => Upgrades.usePotion('speed'));
        Utils.addListener(DOMElements.buyBattlePotionBtn, 'click', () => Upgrades.buyPotion('battle', 150));
        Utils.addListener(DOMElements.useBattlePotionBtn, 'click', () => Upgrades.usePotion('battle'));
    },

    updateDisplay: () => {
        const userData = AppState.userData;
        if (!userData) return;
        const cdLevel = userData.cooldownLevel || 0;
        const luckLevel = userData.luckLevel || 0;
        const potions = userData.potions || { luck: 0, speed: 0, battle: 0 };

        if (DOMElements.cooldownLevelP) DOMElements.cooldownLevelP.textContent = `Cooldown Level: ${cdLevel}`;
        if (DOMElements.luckLevelP) DOMElements.luckLevelP.textContent = `Luck Level: ${luckLevel}`;
        if (DOMElements.cooldownCostSpan) DOMElements.cooldownCostSpan.textContent = 50 * (cdLevel + 1);
        if (DOMElements.luckCostSpan) DOMElements.luckCostSpan.textContent = 100 * (luckLevel + 1);
        Roll.updateCooldownDisplay(); // Updates based on level and potion
        Roll.updateLuckBonusDisplay(); // Updates based on level and potion

        // Potion Counts
        if (DOMElements.luckPotionCountSpan) DOMElements.luckPotionCountSpan.textContent = potions.luck;
        if (DOMElements.speedPotionCountSpan) DOMElements.speedPotionCountSpan.textContent = potions.speed;
        if (DOMElements.battlePotionCountSpan) DOMElements.battlePotionCountSpan.textContent = potions.battle;

        // Potion Use Button States
        Utils.enableButton(DOMElements.useLuckPotionBtn, potions.luck > 0 && !AppState.activeBoosts.luck.active);
        Utils.enableButton(DOMElements.useSpeedPotionBtn, potions.speed > 0 && !AppState.activeBoosts.speed.active);
        Utils.enableButton(DOMElements.useBattlePotionBtn, potions.battle > 0 && !AppState.activeBoosts.battle.active);
    },

    upgradeCooldown: async () => {
        const level = AppState.userData?.cooldownLevel || 0;
        const cost = 50 * (level + 1);
        if ((AppState.userData?.currency || 0) < cost) { alert(`Need ${cost} coins.`); return; }
        const updates = { currency: firebase.firestore.FieldValue.increment(-cost), cooldownLevel: firebase.firestore.FieldValue.increment(1) };
        try { await Firestore.updateUserData(updates); Utils.log('info', "Cooldown upgraded."); }
        catch (error) { Utils.log('error', "Upgrade failed:", error); alert("Upgrade failed."); }
    },

    upgradeLuck: async () => {
        const level = AppState.userData?.luckLevel || 0;
        const cost = 100 * (level + 1);
        if ((AppState.userData?.currency || 0) < cost) { alert(`Need ${cost} coins.`); return; }
        const updates = { currency: firebase.firestore.FieldValue.increment(-cost), luckLevel: firebase.firestore.FieldValue.increment(1) };
        try { await Firestore.updateUserData(updates); Utils.log('info', "Luck upgraded."); }
        catch (error) { Utils.log('error', "Upgrade failed:", error); alert("Upgrade failed."); }
    },

    buyPotion: async (type, cost) => {
        if (!Constants.POTION_TYPES.includes(type)) return;
        if ((AppState.userData?.currency || 0) < cost) { alert(`Need ${cost} coins.`); return; }
        // Use dot notation for nested field update
        const updates = { currency: firebase.firestore.FieldValue.increment(-cost), [`potions.${type}`]: firebase.firestore.FieldValue.increment(1) };
        try { await Firestore.updateUserData(updates); Utils.log('info', `Bought ${type} potion.`); }
        catch (error) { Utils.log('error', `Buy potion failed:`, error); alert(`Buy failed.`); }
    },

    usePotion: (type) => {
        if (!Constants.POTION_TYPES.includes(type)) return;
        const potions = AppState.userData?.potions || {};
        if ((potions[type] || 0) <= 0) { alert(`No ${type} potions.`); return; }

        let boostApplied = false;
        const updates = { [`potions.${type}`]: firebase.firestore.FieldValue.increment(-1) };

        if (type === 'luck' && !AppState.activeBoosts.luck.active) { Upgrades.startBoostTimer('luck'); boostApplied = true; }
        else if (type === 'speed' && !AppState.activeBoosts.speed.active) { Upgrades.startBoostTimer('speed'); boostApplied = true; }
        else if (type === 'battle' && !AppState.activeBoosts.battle.active) {
            // Battle boost is a flag, not a timer
            AppState.activeBoosts.battle.active = true;
            updates.battleBoostActive = true; // Persist the flag
            boostApplied = true;
        }

        if (!boostApplied && type !== 'battle') alert(`Boost for ${type} already active! Potion consumed.`);

        // Save the potion decrement and potential battle boost flag update
        Firestore.updateUserData(updates).catch(error => {
            Utils.log('error', `Potion use save failed:`, error); alert("Save failed.");
            // Consider rolling back local state changes on save failure?
        });
        UI.updateAll(); // Optimistic UI update (buttons disable, timers might start)
    },

    startBoostTimer: (boostType) => {
        const boost = AppState.activeBoosts[boostType];
        if (!boost || boost.active) return; // Already active or invalid type

        boost.active = true;
        boost.remaining = Date.now() + Constants.BOOST_DURATION_MS;
        if (boost.timer) clearInterval(boost.timer); // Clear existing timer if any

        const intervalCallback = () => {
            if (!boost.active) { // Stop if deactivated externally (e.g., logout)
                clearInterval(boost.timer);
                boost.timer = null;
                return;
            }
            const now = Date.now();
            if (now >= boost.remaining) {
                // Timer expired
                boost.active = false;
                clearInterval(boost.timer);
                boost.timer = null;
                Utils.log('info', `${Utils.capitalize(boostType)} boost expired.`);
                UI.updateAll(); // Update UI to reflect expired boost
            } else {
                // Timer still running - UI update happens periodically via updateBoostStatus
                // No need to call UI.updateAll() every second here.
            }
        };
        boost.timer = setInterval(intervalCallback, 1000); // Check every second
        UI.updateAll(); // Initial UI update to show active boost
    }
}; // End Upgrades Module

// --- Cases Module ---
const Cases = {
    initialize: () => {
        if (DOMElements.caseButtonsContainer) {
            // Add static buttons if not already present (or populate dynamically based on user unlocks?)
            Object.keys(Constants.CASE_PROBABILITIES).forEach(caseType => {
                const caseData = Constants.CASE_PROBABILITIES[caseType];
                const button = document.createElement('button');
                button.id = `open${Utils.capitalize(caseType)}CaseBtn`;
                button.className = 'btn btn-case';
                button.textContent = `Open ${Utils.capitalize(caseType)} (${caseData.cost} Coins)`;
                DOMElements.caseButtonsContainer.appendChild(button);
            });
            // Use event delegation on the container
            Utils.addListener(DOMElements.caseButtonsContainer, 'click', Cases.handleButtonClick);
        }
    },

    handleButtonClick: (event) => {
        const button = event.target.closest('button.btn-case');
        if (!button || !button.id) return;
        const caseType = button.id.replace('open', '').replace('CaseBtn', '').toLowerCase();
        if (Constants.CASE_PROBABILITIES[caseType]) Cases.openCase(caseType);
        else Utils.log('warn', `Clicked unknown case button: ${button.id}`);
    },

    openCase: async (caseTypeName) => {
        const caseData = Constants.CASE_PROBABILITIES[caseTypeName];
        if (!caseData) return;
        if ((AppState.userData?.currency || 0) < caseData.cost) { alert(`Need ${caseData.cost} coins.`); return; }

        Utils.disableButton(DOMElements.caseButtonsContainer?.querySelectorAll('button'));

        let nextCardId = null;
        let winningCard = null;
        let droppedPotionType = null;
        const db = AppState.db;
        const counterRef = db.collection('counters').doc('cardCounter');
        const userRef = db.collection('users').doc(AppState.currentUserId);

        try {
            // --- Transaction Start (Get ID, Deduct Cost) ---
            await db.runTransaction(async (transaction) => {
                const counterDoc = await transaction.get(counterRef);
                if (!counterDoc.exists) { throw "Counter document ('counters/cardCounter') not found!"; }
                nextCardId = (counterDoc.data()?.count || 0) + 1;

                const userDoc = await transaction.get(userRef);
                const currentCurrency = userDoc.data()?.currency || 0;
                if (currentCurrency < caseData.cost) { throw `Insufficient funds (${currentCurrency} < ${caseData.cost}).`; }

                transaction.update(counterRef, { count: nextCardId });
                transaction.update(userRef, { currency: firebase.firestore.FieldValue.increment(-caseData.cost) });
            });
            // --- Transaction End ---

            Utils.log('info', `Case opening: Got card ID ${nextCardId}, deducted ${caseData.cost} currency.`);

            // --- Determine Winning Item BEFORE Generating Reel ---
            const winningRarity = GameLogic.chooseCaseRarityWeighted(caseData.drops);
            winningCard = GameLogic.generateCard(winningRarity, nextCardId);
            droppedPotionType = (Math.random() < caseData.potionChance) ? Constants.POTION_TYPES[Utils.getRandomInt(0, Constants.POTION_TYPES.length - 1)] : null;

            if (!winningCard) {
                throw new Error("Internal error: Failed to generate the winning card object after getting ID.");
            }
            Utils.log('info', `Winning item determined: ${winningCard.name} (${winningCard.rarity})`);


            // --- Generate Enhanced Animation Reel with More Contrast ---
            const itemsToShow = 30;
            const targetItemIndex = Math.max(0, itemsToShow - 5); // Winner lands 5th from end
            const animationItems = new Array(itemsToShow).fill(null); // Initialize array

            // Helper function to get a guaranteed high-rarity bait (adjust pool as desired)
            const generateHighValueBait = () => {
                const baitPool = Constants.RARITIES.filter(r => ['legendary', 'mythic', 'divine', 'cosmic', 'eternal'].includes(r.name));
                const baitRarity = baitPool.length > 0 ? baitPool[Utils.getRandomInt(0, baitPool.length - 1)].name : 'epic';
                return GameLogic.generateCard(baitRarity, 999000 + Math.random() * 1000) || GameLogic.generateCard('epic');
            };

             // Helper function to get a guaranteed low-rarity filler
             const generateLowValueFiller = () => {
                 const fillerPool = Constants.RARITIES.filter(r => ['common', 'uncommon'].includes(r.name));
                 const fillerRarity = fillerPool.length > 0 ? fillerPool[Utils.getRandomInt(0, fillerPool.length - 1)].name : 'common';
                 return GameLogic.generateCard(fillerRarity, 997000 + Math.random() * 1000) || GameLogic.generateCard('common');
             };

            // Place the actual winner
            animationItems[targetItemIndex] = winningCard;

            // Place high-value bait directly adjacent
            if (targetItemIndex > 0) {
                animationItems[targetItemIndex - 1] = generateHighValueBait();
            }
            if (targetItemIndex < itemsToShow - 1) {
                animationItems[targetItemIndex + 1] = generateHighValueBait();
            }

             // Place some low-value items near the bait/winner for contrast
             if (targetItemIndex > 1) {
                 animationItems[targetItemIndex - 2] = generateLowValueFiller();
             }
             if (targetItemIndex < itemsToShow - 2) {
                 animationItems[targetItemIndex + 2] = generateLowValueFiller();
             }

            // Fill the remaining slots
            for (let i = 0; i < itemsToShow; i++) {
                if (animationItems[i] === null) { // If slot is not already filled
                     // Fill remaining with a mix, maybe weighted slightly lower than case odds?
                     // Or just use case odds for simplicity here.
                     const randomReelRarity = GameLogic.chooseCaseRarityWeighted(caseData.drops);
                     animationItems[i] = GameLogic.generateCard(randomReelRarity, 998000 + Math.random() * 1000) || GameLogic.generateCard('common');
                }
            }
            // --- End Reel Generation ---


            // --- Start Animation ---
             Utils.log('info', 'Starting case animation with generated reel.');
             // Pass the generated reel, the winner, and the callback
             // The delay parameter in startCaseOpeningAnimation will use its default (3600ms)
            UI.startCaseOpeningAnimation(animationItems, winningCard, async () => {
                // (Callback code remains the same - saves winner, handles potion, updates UI)
                try {
                    let updates = {};
                    let msg = `Opened: <strong style="color:${winningCard.color}">${winningCard.name}</strong> (${Utils.capitalize(winningCard.rarity)})!`;

                    await Firestore.addUserArrayItem('inventory', winningCard);
                    Utils.log('info', `Saved winning card ${winningCard.id} to inventory.`);

                    if (droppedPotionType) {
                        updates[`potions.${droppedPotionType}`] = firebase.firestore.FieldValue.increment(1);
                        msg += `<br>+1 ${Utils.capitalize(droppedPotionType)} Potion!`;
                         Utils.log('info', `Attempting to add +1 ${droppedPotionType} potion.`);
                        await Firestore.updateUserData(updates);
                         Utils.log('info', `Potion update successful.`);
                    }

                    if (DOMElements.caseResultDiv) {
                        DOMElements.caseResultDiv.innerHTML = `<p>${msg}</p>`;
                        Utils.setActive(DOMElements.caseResultDiv);
                        DOMElements.caseResultDiv.classList.add('visible');
                    }
                } catch (saveError) {
                     let alertMsg = "Error saving winnings after animation.";
                     Utils.log('error', "Case reward save failed (post-animation):", saveError);
                     if (saveError?.message?.includes('inventory')) {
                         alertMsg = "Error saving the card to inventory. Check console.";
                     } else if (saveError?.message?.includes('potion')) {
                         alertMsg = "Error adding potion reward. Check console.";
                     }
                     alert(alertMsg); // More specific alert
                    if (DOMElements.caseResultDiv) { DOMElements.caseResultDiv.innerHTML = `<p style="color: var(--danger-color);">Error saving winnings. Check console.</p>`; Utils.setActive(DOMElements.caseResultDiv); DOMElements.caseResultDiv.classList.add('visible'); }
                } finally {
                     Utils.enableButton(DOMElements.caseButtonsContainer?.querySelectorAll('button'));
                }
            });
            // --- End Animation ---

        } catch (error) {
            Utils.log('error', "Case opening failed:", error);
            alert(`Case Opening Failed: ${error.message || error}`);
            Utils.enableButton(DOMElements.caseButtonsContainer?.querySelectorAll('button'));
        }
    }
}; // End Cases Module

// --- Battle Module ---
const Battle = {
    initialize: () => {
        Utils.addListener(DOMElements.startBattleBtn, 'click', Battle.start);
        Utils.addListener(DOMElements.nextTurnBtn, 'click', Battle.executeNextTurn);
    },

    start: () => {
        const deck = AppState.userData?.deck;
        if (!deck || deck.length === 0) { alert("Deck empty!"); return; }
        if (deck.length > Constants.DECK_SIZE_LIMIT) { alert(`Deck > ${Constants.DECK_SIZE_LIMIT} cards!`); return; }
        if (AppState.currentBattleState?.isActive) { alert("Battle active!"); return; }

        const applyBattleBoost = AppState.activeBoosts.battle.active;
        let updates = {};
        if (applyBattleBoost) {
            // Consume boost if active
            AppState.activeBoosts.battle.active = false;
            updates.battleBoostActive = false; // Update flag in Firestore
        }

        AppState.currentBattleState = {
            isActive: true, round: 1,
            playerDeck: deck.map(card => Battle.createBattleCard(card, applyBattleBoost)), // Apply boost here
            enemyDeck: Battle.generateEnemyDeck(deck.length).map(card => Battle.createBattleCard(card, false)), // Enemy never boosted
            turnLog: [], winner: null
        };

        // Save boost consumption immediately if used
        if (applyBattleBoost) Firestore.updateUserData(updates).catch(err => Utils.log('error', "Battle boost flag save failed:", err));

        // Reset UI
        Utils.showElement(DOMElements.battleAreaDiv);
        Utils.hideElement(DOMElements.nextTurnBtn);
        if (DOMElements.turnLogDiv) DOMElements.turnLogDiv.innerHTML = "";
        if (DOMElements.battleResultDiv) { DOMElements.battleResultDiv.innerHTML = ""; Utils.setInactive(DOMElements.battleResultDiv); }
        Utils.disableButton(DOMElements.startBattleBtn);

        Battle.logTurn("--- Battle Start! ---");
        Battle.logTurn(`Player (${AppState.currentBattleState.playerDeck.length}) vs Enemy (${AppState.currentBattleState.enemyDeck.length})`);
        if (applyBattleBoost) Battle.logTurn("** Player boosted! **");
        UI.updateBattleUI();
        Utils.showElement(DOMElements.nextTurnBtn); // Show Next Turn button
        UI.updateAll(); // Update header etc.
    },

    createBattleCard: (originalCard, isBoosted) => {
        // Deep copy the card to avoid modifying inventory/deck versions
        const battleCard = JSON.parse(JSON.stringify(originalCard || {}));
        battleCard.attack = battleCard.attack || 1; // Ensure min 1 stat
        battleCard.defense = battleCard.defense || 1;
        battleCard.maxHp = battleCard.attack + battleCard.defense;
        battleCard.hp = battleCard.maxHp; // Start at full HP
        battleCard.isDefeated = false;
        // Apply boost if applicable
        if (isBoosted) {
            battleCard.attack = Math.ceil(battleCard.attack * 1.2);
            battleCard.defense = Math.ceil(battleCard.defense * 1.2);
            battleCard.maxHp = battleCard.attack + battleCard.defense; // Recalc max HP
            battleCard.hp = battleCard.maxHp; // Start at boosted full HP
        }
        return battleCard;
    },

    generateEnemyDeck: (size) => {
        // Scale enemy based on player's total power (inventory + score)
        const power = GameLogic.calculateTotalPower();
        let tier = 0, mult = 1.0;
        // Define power thresholds and multipliers for scaling
        if (power > 5000) { tier = 4; mult = 1.25; } else if (power > 2000) { tier = 3; mult = 1.15; }
        else if (power > 500) { tier = 2; mult = 1.05; } else if (power > 100) { tier = 1; }
        Utils.log('info', `Enemy Deck Generation: Player Power=${power}, Tier=${tier}, Stat Multiplier=${mult}`);

        // Determine allowed rarities based on tier
        let allowed = ["common", "uncommon"];
        if (tier >= 1) allowed.push("rare"); if (tier >= 2) allowed.push("epic");
        if (tier >= 3) allowed.push("legendary"); if (tier >= 4) allowed.push("mythic", "divine");
        const pool = Constants.RARITIES.filter(r => allowed.includes(r.name));
        if (pool.length === 0) pool.push(Constants.RARITIES[0]); // Failsafe

        // Generate enemy cards
        return Array.from({ length: size }, () => {
            const name = pool[Utils.getRandomInt(0, pool.length - 1)].name;
            let card = GameLogic.generateCard(name);
            if (card) {
                // Apply stat multiplier and rename
                card.attack = Math.max(1, Math.ceil((card.attack || 1) * mult));
                card.defense = Math.max(1, Math.ceil((card.defense || 1) * mult));
                card.name = `Enemy ${card.name}`;
                return card;
            } else return GameLogic.generateCard('common'); // Failsafe card generation
        });
    },

    executeNextTurn: () => {
        const state = AppState.currentBattleState;
        // Ensure battle is active and cards exist
        if (!state?.isActive || !state.playerDeck?.length || !state.enemyDeck?.length) {
            Battle.checkBattleEnd(); return; // End if no cards left
        }
        Utils.disableButton(DOMElements.nextTurnBtn); // Prevent spamming
        const playerCard = state.playerDeck[0]; const enemyCard = state.enemyDeck[0];
        Battle.logTurn(`--- Round ${state.round} ---`);

        // Player attacks enemy
        if (!playerCard.isDefeated && !enemyCard.isDefeated) {
            const pDmg = Battle.calculateDamage(playerCard, enemyCard);
            enemyCard.hp -= pDmg;
            Battle.logTurn(`${playerCard.name} hits ${enemyCard.name} for ${pDmg}. Enemy HP: ${Math.max(0, enemyCard.hp)}/${enemyCard.maxHp}`);
            if (enemyCard.hp <= 0) {
                enemyCard.isDefeated = true;
                Battle.logTurn(`** ${enemyCard.name} defeated! **`);
                state.enemyDeck.shift(); // Remove defeated enemy card
            }
        }
        if (Battle.checkBattleEnd()) return; // Check if player won

        // Enemy attacks player
        const currentEnemy = state.enemyDeck[0]; // Re-check as it might have shifted
        if (currentEnemy && !currentEnemy.isDefeated && !playerCard.isDefeated) {
            const eDmg = Battle.calculateDamage(currentEnemy, playerCard);
            playerCard.hp -= eDmg;
            Battle.logTurn(`${currentEnemy.name} hits ${playerCard.name} for ${eDmg}. Player HP: ${Math.max(0, playerCard.hp)}/${playerCard.maxHp}`);
            if (playerCard.hp <= 0) {
                playerCard.isDefeated = true;
                Battle.logTurn(`** ${playerCard.name} defeated! **`);
                state.playerDeck.shift(); // Remove defeated player card
            }
        }
        state.round++;
        UI.updateBattleUI();
        // Re-enable button if battle continues
        if (!Battle.checkBattleEnd()) Utils.enableButton(DOMElements.nextTurnBtn);
    },

    calculateDamage: (attacker, defender) => Math.max(1, Math.floor((attacker.attack || 1) - ((defender.defense || 1) / 3))), // Simple damage formula

    checkBattleEnd: () => {
        const state = AppState.currentBattleState;
        if (!state || !state.isActive) return false; // Battle already ended or not started
        const playerWon = state.enemyDeck.length === 0;
        const enemyWon = state.playerDeck.length === 0;

        if (playerWon || enemyWon) {
            state.isActive = false; state.winner = playerWon ? "Player" : "Enemy";
            Utils.log('info', `Battle Over! Winner: ${state.winner}`);
            Battle.logTurn(`--- Battle Over! ${state.winner} wins! ---`);

            if (playerWon) {
                const rewardCoins = Battle.calculateReward(state.round);
                const scoreGain = Math.floor(rewardCoins / Constants.BATTLE_WIN_SCORE_DIVISOR);
                Battle.logTurn(`Player gets ${rewardCoins} coins, ${scoreGain} score!`);
                const updates = {
                     currency: firebase.firestore.FieldValue.increment(rewardCoins),
                     singlePlayerScore: firebase.firestore.FieldValue.increment(scoreGain) // Update singlePlayerScore
                };
                Firestore.updateUserData(updates)
                    .then(() => DailyChallenge.recordWin()) // Record win for daily challenge
                    .catch(err => Utils.log('error', "Reward save failed:", err));
            } else Battle.logTurn("Better luck next time!");

            // Reset UI for next battle
            Utils.hideElement(DOMElements.nextTurnBtn); Utils.enableButton(DOMElements.startBattleBtn);
            if (DOMElements.battleResultDiv) { DOMElements.battleResultDiv.innerHTML = `<h2>${state.winner} Wins!</h2>`; Utils.setActive(DOMElements.battleResultDiv); }
            UI.updateAll(); // Update header with new currency/score
            return true; // Battle ended
        }
        return false; // Battle continues
    },

    calculateReward: (rounds) => 25 + Math.max(0, rounds - 1) * 5 + Utils.getRandomInt(5, 25), // Base + bonus per round + random bonus

    logTurn: (message) => {
        if (!AppState.currentBattleState) return;
        AppState.currentBattleState.turnLog.push(message);
        UI.updateBattleUI(); // Update log display
    }
}; // End Battle Module

// --- Leaderboard Module ---
const Leaderboard = {
    initialize: () => { }, // Listener setup handles data display
    updateDisplay: () => {
        // Update player's own score display if needed (snapshot handles the list)
        if (DOMElements.playerScoreDisplayP) {
             // Display both scores in the header info box too
             DOMElements.playerScoreDisplayP.innerText = `Your Scores - SP: ${AppState.userData?.singlePlayerScore || 0} | MP: ${AppState.userData?.multiplayerScore || 0}`;
        }
    }
}; // End Leaderboard Module

// --- Daily Challenge Module ---
const DailyChallenge = {
    initialize: () => {
        DailyChallenge.checkAndGenerateIfNeeded(); // Generate challenge on init if needed
        Utils.addListener(DOMElements.claimDailyChallengeBtn, 'click', DailyChallenge.claimReward);
        Utils.addListener(DOMElements.generateNewChallengeBtn, 'click', DailyChallenge.handleGenerateNewClick);
    },

    checkAndGenerateIfNeeded: async () => {
        if (!AppState.userData) return; // Need user data
        const today = new Date().toLocaleDateString(); // Get date string like "MM/DD/YYYY"
        const currentChallenge = AppState.userData.dailyChallenge;
        // Generate if no challenge exists, or if date doesn't match today
        if (!currentChallenge || typeof currentChallenge !== 'object' || currentChallenge.date !== today) {
            Utils.log('info', "Generating new daily challenge.");
            await DailyChallenge.generateNew();
        }
    },

    generateNew: async () => {
        const today = new Date().toLocaleDateString();
        const targetWins = Utils.getRandomInt(3, 5);
        const reward = targetWins * 50 + Utils.getRandomInt(25, 75);
        const newChallenge = { date: today, description: `Win ${targetWins} battles.`, wins: 0, target: targetWins, reward: reward, claimed: false };
        try { await Firestore.updateUserData({ dailyChallenge: newChallenge }); Utils.log('info', "New daily challenge saved."); }
        catch (error) { Utils.log('error', "Save new challenge failed:", error); alert("Failed to generate challenge."); }
    },

    handleGenerateNewClick: () => {
        // Allow generating a new one, but warn if progress will be lost
        const dc = AppState.userData?.dailyChallenge;
        if (dc && dc.wins > 0 && !dc.claimed && !confirm("Generating a new challenge will reset your current progress. Continue?")) return;
        DailyChallenge.generateNew();
    },

    recordWin: async () => {
        // Called after a successful battle win
        const dc = AppState.userData?.dailyChallenge;
        // Only increment if challenge exists, matches today, not claimed, and not already complete
        if (!dc || dc.claimed || dc.date !== new Date().toLocaleDateString() || (dc.wins || 0) >= dc.target) return;
        try { await Firestore.updateUserData({ 'dailyChallenge.wins': firebase.firestore.FieldValue.increment(1) }); Utils.log('info', "Daily challenge win recorded."); }
        catch (error) { Utils.log('error', "Record win failed:", error); }
    },

    claimReward: async () => {
        const dc = AppState.userData?.dailyChallenge;
        if (!dc || dc.claimed || (dc.wins || 0) < dc.target) { alert("Challenge not completed or already claimed!"); return; }
        const scoreGain = Math.floor(dc.reward / Constants.DAILY_CHALLENGE_SCORE_DIVISOR);
        const updates = { currency: firebase.firestore.FieldValue.increment(dc.reward), playerScore: firebase.firestore.FieldValue.increment(scoreGain), 'dailyChallenge.claimed': true };
        try {
            await Firestore.updateUserData(updates); Utils.log('info', "Daily reward claimed.");
            alert(`Challenge complete! +${dc.reward} coins, +${scoreGain} score.`);
        } catch (error) { Utils.log('error', "Claim reward failed:", error); alert("Claim failed."); }
    },

    updateDisplay: () => {
        const dc = AppState.userData?.dailyChallenge;
        if (!DOMElements.dailyChallengeInfoDiv) return;
        if (!dc || typeof dc !== 'object') {
            DOMElements.dailyChallengeInfoDiv.innerHTML = "<p>No daily challenge active. Generate one!</p>";
            Utils.hideElement(DOMElements.claimDailyChallengeBtn);
            return;
        }
        // Display challenge info
        DOMElements.dailyChallengeInfoDiv.innerHTML = `<p>${dc.description}</p><p>Progress: ${dc.wins || 0}/${dc.target}</p><p>Reward: ${dc.reward} Coins</p>${dc.claimed ? '<p style="color:var(--success-color);">Claimed!</p>' : ''}`;
        // Show/hide claim button
        const canClaim = (dc.wins || 0) >= dc.target && !dc.claimed;
        if (canClaim) { Utils.showElement(DOMElements.claimDailyChallengeBtn); Utils.enableButton(DOMElements.claimDailyChallengeBtn); }
        else { Utils.hideElement(DOMElements.claimDailyChallengeBtn); }
    }
}; // End DailyChallenge Module

// --- Bank Module ---
const Bank = {
    initialize: () => {
        Utils.addListener(DOMElements.depositBtn, 'click', Bank.deposit);
        Utils.addListener(DOMElements.withdrawBtn, 'click', Bank.withdraw);
        Utils.addListener(DOMElements.takeLoanBtn, 'click', Bank.takeLoan);
        Utils.addListener(DOMElements.repayLoanBtn, 'click', Bank.repayLoan);
        // Offline changes are processed on user data snapshot
    },

    processOfflineChanges: () => {
        // Calculates income/interest gained while offline
        if (!AppState.userData) return { hasChanges: false, updates: {} };
        const userData = AppState.userData, now = Date.now(); let changed = false; const updates = {};

        // Passive Income
        const lastPassiveTs = userData.lastPassiveIncomeTimestamp || now; // Default to now if never received
        const passiveIntervals = Math.floor((now - lastPassiveTs) / Constants.PASSIVE_INCOME_INTERVAL_MS);
        if (passiveIntervals > 0) {
            const income = passiveIntervals * Math.floor(GameLogic.calculateTotalPower() / Constants.PASSIVE_INCOME_POWER_DIVISOR);
            if (income > 0) { updates.currency = firebase.firestore.FieldValue.increment(income); Utils.log('info', `Calculated +${income} passive income.`); }
            // Update timestamp to the last completed interval
            updates.lastPassiveIncomeTimestamp = lastPassiveTs + passiveIntervals * Constants.PASSIVE_INCOME_INTERVAL_MS;
            changed = true;
        }

        // Savings Interest (Compound)
        let savings = userData.bankSavings || 0, savingsInterest = 0;
        if (savings > 0 && userData.lastSavingsTimestamp > 0) { // Need savings and previous timestamp
            const lastSavingsTs = userData.lastSavingsTimestamp;
            const savingsIntervals = Math.floor((now - lastSavingsTs) / Constants.SAVINGS_INTEREST_INTERVAL_MS);
            if (savingsIntervals > 0) {
                let compoundSavings = savings;
                for (let i = 0; i < savingsIntervals; i++) { const interest = Math.floor(compoundSavings * Constants.SAVINGS_INTEREST_RATE); savingsInterest += interest; compoundSavings += interest; }
                if (savingsInterest > 0) updates.bankSavings = firebase.firestore.FieldValue.increment(savingsInterest);
                updates.lastSavingsTimestamp = lastSavingsTs + savingsIntervals * Constants.SAVINGS_INTEREST_INTERVAL_MS;
                changed = true; Utils.log('info', `Calculated +${savingsInterest} savings interest.`);
            }
        }

        // Loan Interest (Compound)
        let loan = userData.loanAmount || 0, loanInterest = 0;
        if (loan > 0 && userData.lastLoanInterestTimestamp > 0) { // Need loan and previous timestamp
            const lastLoanTs = userData.lastLoanInterestTimestamp;
            const loanIntervals = Math.floor((now - lastLoanTs) / Constants.LOAN_INTEREST_INTERVAL_MS);
            if (loanIntervals > 0) {
                let compoundLoan = loan;
                for (let i = 0; i < loanIntervals; i++) { const interest = Math.ceil(compoundLoan * Constants.LOAN_INTEREST_RATE); loanInterest += interest; compoundLoan += interest; }
                if (loanInterest > 0) updates.loanAmount = firebase.firestore.FieldValue.increment(loanInterest);
                updates.lastLoanInterestTimestamp = lastLoanTs + loanIntervals * Constants.LOAN_INTEREST_INTERVAL_MS;
                changed = true; Utils.log('info', `Calculated +${loanInterest} loan interest.`);
            }
        }
        // Merge increments if both fields were updated
        if (updates.currency && typeof updates.currency !== 'number' && updates.bankSavings && typeof updates.bankSavings !== 'number') {
            // This case shouldn't happen with FieldValue.increment, but safer? Or just let Firestore handle merging increments?
        }
        if (updates.currency && typeof updates.currency !== 'number' && updates.loanAmount && typeof updates.loanAmount !== 'number') {

        }

        return { hasChanges: changed, updates: updates };
    },

    saveOfflineBankChanges: (changeResult) => {
        // Called after processing changes, saves them back to Firestore
        if (changeResult.hasChanges && Object.keys(changeResult.updates).length > 0) {
            Utils.log('info', "Saving calculated offline bank changes...");
            Firestore.updateUserData(changeResult.updates).catch(err => Utils.log('error', "Save bank changes failed:", err));
        }
    },

    deposit: async () => {
        const amount = parseInt(DOMElements.depositAmountInput?.value || '0');
        if (isNaN(amount) || amount <= 0) { alert("Invalid amount."); return; }
        if ((AppState.userData?.currency || 0) < amount) { alert("Not enough coins."); return; }
        const wasZero = (AppState.userData?.bankSavings || 0) === 0;
        const updates = { currency: firebase.firestore.FieldValue.increment(-amount), bankSavings: firebase.firestore.FieldValue.increment(amount) };
        // Start tracking interest only on the first deposit
        if (wasZero) updates.lastSavingsTimestamp = Date.now();
        try { await Firestore.updateUserData(updates); if (DOMElements.depositAmountInput) DOMElements.depositAmountInput.value = ''; Utils.log('info', `Deposited ${amount}.`); }
        catch (error) { Utils.log('error', "Deposit failed:", error); alert("Deposit failed."); }
    },

    withdraw: async () => {
    const currentSavings = AppState.userData?.bankSavings || 0;
    if (currentSavings <= 0) { 
        alert("No savings to withdraw."); 
        return; 
    }
        // Process any pending interest FIRST before calculating withdrawal
        // Calculate the amount available *after* potential interest
        const changes = Bank.processOfflineChanges();
    const interestGained = changes.updates?.bankSavings?.operand || 0;
    const finalAmount = currentSavings + interestGained;

        if (finalAmount <= 0) { alert("Savings is zero or negative after interest calculation."); Bank.saveOfflineBankChanges(changes); return; }
        

        // Prepare updates: include pending changes, set savings to 0, reset timestamp, add withdrawn amount to currency
        
    const updates = {
        currency: firebase.firestore.FieldValue.increment(finalAmount),
        bankSavings: 0,
        lastSavingsTimestamp: 0
    };
        // Add finalAmount to currency, considering if currency was already being updated
        if (updates.currency && typeof updates.currency !== 'number') { // Already an increment update
            updates.currency = firebase.firestore.FieldValue.increment(updates.currency.operand + finalAmount);
        } else { // No other currency update pending
            updates.currency = firebase.firestore.FieldValue.increment(finalAmount);
        }

        try  {
        await Firestore.updateUserData(updates);
        alert(`Withdrew ${finalAmount} coins including ${interestGained} interest.`);
    } catch (error) {
        Utils.log('error', "Withdraw failed:", error);
        alert("Withdraw failed.");
    }
},

    takeLoan: async () => {
        const amount = parseInt(DOMElements.loanRequestAmountInput?.value || '0');
        if (isNaN(amount) || amount <= 0) { alert("Invalid amount."); return; }
        if (amount > Constants.MAX_LOAN_AMOUNT) { alert(`Maximum loan amount is ${Constants.MAX_LOAN_AMOUNT}.`); return; }
        if ((AppState.userData?.loanAmount || 0) > 0) { alert("You must repay your existing loan first."); return; }
        const updates = { currency: firebase.firestore.FieldValue.increment(amount), loanAmount: amount, lastLoanInterestTimestamp: Date.now() };
        try { await Firestore.updateUserData(updates); if (DOMElements.loanRequestAmountInput) DOMElements.loanRequestAmountInput.value = ''; Utils.log('info', `Loan taken: ${amount}.`); alert(`Loan of ${amount} taken.`); }
        catch (error) { Utils.log('error', "Take loan failed:", error); alert("Failed to take loan."); }
    },

    repayLoan: async () => {
        const amount = parseInt(DOMElements.repayLoanAmountInput?.value || '0');
        if (isNaN(amount) || amount <= 0) { alert("Invalid amount."); return; }
        if ((AppState.userData?.currency || 0) < amount) { alert("Not enough coins to repay that amount."); return; }
        const currentLoan = AppState.userData?.loanAmount || 0;
        if (currentLoan <= 0) { alert("You don't have an active loan."); return; }
        // Process any pending interest FIRST
        const changes = Bank.processOfflineChanges();
        const interestAccrued = (changes.updates?.loanAmount?.operand || 0);
        const finalLoan = currentLoan + interestAccrued;
        if (finalLoan <= 0) { alert("Loan amount is zero or negative after interest calculation."); Bank.saveOfflineBankChanges(changes); return; }

        const repayment = Math.min(amount, finalLoan); // Can't repay more than owed
        const newLoan = finalLoan - repayment;

        // Prepare updates: include pending changes, set new loan amount, deduct from currency
        let updates = { ...changes.updates, loanAmount: newLoan };
        // Deduct repayment from currency, considering if currency was already being updated
        if (updates.currency && typeof updates.currency !== 'number') {
            updates.currency = firebase.firestore.FieldValue.increment(updates.currency.operand - repayment);
        } else {
            updates.currency = firebase.firestore.FieldValue.increment(-repayment);
        }
        // If loan fully repaid, reset timestamp
        if (newLoan <= 0) { updates.loanAmount = 0; updates.lastLoanInterestTimestamp = 0; }

        try { await Firestore.updateUserData(updates); if (DOMElements.repayLoanAmountInput) DOMElements.repayLoanAmountInput.value = ''; Utils.log('info', `Repaid ${repayment}. New loan: ${newLoan}`); alert(`Repaid ${repayment}.`); if (newLoan <= 0) alert("Loan fully repaid!"); }
        catch (error) { Utils.log('error', "Repay loan failed:", error); alert("Repay failed."); }
    },

    updateDisplay: () => {
        const userData = AppState.userData; if (!userData) return;
        const now = Date.now();

        // Passive Income Display
        const incomeRate = Math.floor(GameLogic.calculateTotalPower() / Constants.PASSIVE_INCOME_POWER_DIVISOR);
        const timeToNextPassive = Math.max(0, Constants.PASSIVE_INCOME_INTERVAL_MS - (now - (userData.lastPassiveIncomeTimestamp || now)));
        if (DOMElements.passiveIncomeRateP) DOMElements.passiveIncomeRateP.textContent = `Rate: ${incomeRate} Coins / 5h`;
        if (DOMElements.nextPassiveIncomeTimeP) DOMElements.nextPassiveIncomeTimeP.textContent = `Next: ${Utils.formatTimeRemaining(timeToNextPassive)}`;

        // Savings Display
        const savings = userData.bankSavings || 0;
        let timeToNextSavings = Infinity;
        if (savings > 0 && userData.lastSavingsTimestamp > 0) timeToNextSavings = Math.max(0, Constants.SAVINGS_INTEREST_INTERVAL_MS - (now - (userData.lastSavingsTimestamp || now)));
        if (DOMElements.savingsBalanceP) DOMElements.savingsBalanceP.textContent = `Balance: ${savings} Coins`;
        if (DOMElements.nextSavingsInterestTimeP) DOMElements.nextSavingsInterestTimeP.textContent = savings > 0 ? `Next Interest (${(Constants.SAVINGS_INTEREST_RATE * 100).toFixed(1)}%): ${Utils.formatTimeRemaining(timeToNextSavings)}` : 'Deposit to earn interest.';

        // Loan Display
        const loan = userData.loanAmount || 0;
        let timeToNextLoan = Infinity;
        if (loan > 0 && userData.lastLoanInterestTimestamp > 0) timeToNextLoan = Math.max(0, Constants.LOAN_INTEREST_INTERVAL_MS - (now - (userData.lastLoanInterestTimestamp || now)));
        if (DOMElements.loanAmountDisplayP) DOMElements.loanAmountDisplayP.textContent = `Loan: ${loan} Coins`;
        if (DOMElements.nextLoanInterestTimeP) DOMElements.nextLoanInterestTimeP.textContent = loan > 0 ? `Next Interest (${(Constants.LOAN_INTEREST_RATE * 100).toFixed(1)}%): ${Utils.formatTimeRemaining(timeToNextLoan)}` : 'No loan.';

        // Enable/Disable Buttons
        Utils.enableButton(DOMElements.depositBtn, (userData.currency || 0) > 0);
        Utils.enableButton(DOMElements.withdrawBtn, savings > 0);
        Utils.enableButton(DOMElements.takeLoanBtn, loan <= 0); // Can only take loan if no current loan
        Utils.enableButton(DOMElements.repayLoanBtn, loan > 0 && (userData.currency || 0) > 0);
    }
}; // End Bank Module

// --- Chat Module ---
const Chat = {
    initialize: () => {
        Utils.addListener(DOMElements.sendChatBtn, 'click', Chat.sendMessage);
        Utils.addListener(DOMElements.chatInput, 'keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent the default action
                Chat.sendMessage();
            }
        });
    },

    sendMessage: async () => {
        // Check if user is logged in (relying only on userId now)
        if (!AppState.currentUserId) {
            alert("Login required to chat.");
            Utils.log('warn', 'Chat send blocked: User ID not found.');
            return;
        }

        const message = DOMElements.chatInput.value.trim();
        if (!message) {
            alert("Message cannot be empty.");
            return; // No empty messages
        }
        
        if (message.length > Constants.CHAT_MESSAGE_MAX_LENGTH) {
            alert(`Max ${Constants.CHAT_MESSAGE_MAX_LENGTH} characters exceeded.`);
            return; 
        }

        Utils.disableButton(DOMElements.sendChatBtn);
        if (DOMElements.chatInput) DOMElements.chatInput.disabled = true; // Prevent multi-send

        const data = {
            userId: AppState.currentUserId,
            displayName: AppState.userData.displayName,
            message: message,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        };

        try {
            // Attempt to send the chat message
            await Firestore.addDocument('chatMessages', data);
            if (DOMElements.chatInput) {
                DOMElements.chatInput.value = ''; // Clear input on success
            }
        } catch (error) {
            Utils.log('error', "Failed to send message:", error);
            alert("Error sending message. Please try again.");
        } finally {
            // Re-enable button and input field regardless of success
            Utils.enableButton(DOMElements.sendChatBtn);
            if (DOMElements.chatInput) DOMElements.chatInput.disabled = false;
        }
    }
};

// --- Black Market Module ---
const BlackMarket = {
    initialize: () => {
        // Set up event listeners for buttons related to buying and using items
        Utils.addListener(DOMElements.buyMarketTicketBtn, 'click', BlackMarket.buyTicket);
        Utils.addListener(DOMElements.useMarketTicketBtn, 'click', BlackMarket.useTicket);
        Utils.addListener(DOMElements.useUltraTokenBtn, 'click', BlackMarket.useUltraToken);
        
        // Generate buttons for useable consumable items
        BlackMarket.generateConsumableButtons();
    },
    generateConsumableButtons: () => {
    const consumableTypes = ['exclusive_case', 'exclusive_luck_potion', 'ultra_lucky_roll'];
    const container = document.getElementById('consumableButtonsContainer'); // Ensure correct selector

    if (!container) {
        Utils.log('warn', 'Consumable buttons container not found');
        return;
    }

    consumableTypes.forEach(type => {
        // Check if button already exists to prevent duplicates
        if (!container.querySelector(`[data-consumable-type="${type}"]`)) {
            const button = document.createElement('button');
            button.textContent = `Use ${Utils.capitalize(type.replace(/_/g, ' '))}`;
            button.className = 'btn btn-small btn-primary';
            button.dataset.consumableType = type;
            button.addEventListener('click', () => BlackMarket.useConsumable(type));
            container.appendChild(button);
        }
    });
},
    updateDisplay: () => {
        const userData = AppState.userData; 
        if (!userData) return;

        const tickets = userData.blackMarketTickets || 0, 
              tokens = userData.ultraTokens || 0;
        const consumables = userData.consumables || {};
        const cases = consumables.exclusive_case || 0;
        const potions = consumables.exclusive_luck_potion || 0; 
        const rolls = consumables.ultra_lucky_roll || 0;

        // Update the display elements with the current counts
        if (DOMElements.marketTicketCountSpan) {
            DOMElements.marketTicketCountSpan.textContent = tickets;
        }
        if (DOMElements.ultraTokenCountSpan) {
            DOMElements.ultraTokenCountSpan.textContent = tokens;
        }
        if (DOMElements.exclusiveCaseCountSpan) {
            DOMElements.exclusiveCaseCountSpan.textContent = cases;
        }
        if (DOMElements.exclusiveLuckPotionCountSpan) {
            DOMElements.exclusiveLuckPotionCountSpan.textContent = potions;
        }
        if (DOMElements.ultraLuckyRollCountSpan) {
            DOMElements.ultraLuckyRollCountSpan.textContent = rolls;
        }

        // Enable/disable buttons based on counts
        Utils.enableButton(DOMElements.useMarketTicketBtn, tickets > 0);
        Utils.enableButton(DOMElements.useUltraTokenBtn, tokens > 0);
        Utils.enableButton(DOMElements.useExclusiveCaseBtn, cases > 0);
        Utils.enableButton(DOMElements.useExclusiveLuckPotionBtn, potions > 0 && !AppState.activeBoosts.exclusiveLuck.active);
        Utils.enableButton(DOMElements.useUltraLuckyRollBtn, rolls > 0);

        // Optionally hide if count is 0
        Utils.toggleVisibility(DOMElements.useExclusiveCaseBtn, cases > 0);
        Utils.toggleVisibility(DOMElements.useExclusiveLuckPotionBtn, potions > 0);
        Utils.toggleVisibility(DOMElements.useUltraLuckyRollBtn, rolls > 0);
    },

    buyTicket: async () => {
        const cost = Constants.BLACK_MARKET_TICKET_COST;
        if ((AppState.userData?.currency || 0) < cost) { 
            alert(`Need ${cost} coins.`);
            return; 
        }

        const updates = { 
            currency: firebase.firestore.FieldValue.increment(-cost), 
            blackMarketTickets: firebase.firestore.FieldValue.increment(1) 
        };

        try { 
            await Firestore.updateUserData(updates);
            alert("Ticket purchased!"); 
        } catch (error) { 
            Utils.log('error', "Buy ticket failed:", error); 
            alert("Purchase failed."); 
        }
    },
    handleExclusiveCase: async () => {
    // Call the function to generate a card
    const newCard = GameLogic.generateCard('exclusive'); // Assuming 'exclusive' is the rarity for exclusive cases

    // Ensure card generation worked
    if (!newCard) {
        alert("Failed to generate the card. Please try again.");
        return;
    }
    
    // Save the newly generated card to the user's inventory
    try {
        await Firestore.addUserArrayItem('inventory', newCard);
        alert(`You received: ${newCard.name} (${Utils.capitalize(newCard.rarity)})!`); // Alert the user with the received card details
    } catch (error) {
        Utils.log('error', "Error adding exclusive card to inventory:", error);
        alert(`Failed to add the card to inventory: ${error.message}`);
    }
},

useUltraLuckyRoll: async () => {
    const r = Constants.ULTRA_LUCKY_ROLL_REWARDS;
    let msg = "Ultra Lucky Roll results:";
    const updates = {};

    // Grant Potions
    for (const p in r.potions) { 
        const c = r.potions[p];
        if (c > 0) { 
            updates[`potions.${p}`] = firebase.firestore.FieldValue.increment(c);
            msg += `\n+${c} ${Utils.capitalize(p)} Potion(s)`;
        }
    }

    // Grant Coins
    if (r.coins > 0) { 
        updates.currency = firebase.firestore.FieldValue.increment(r.coins); 
        msg += `\n+${r.coins} Coins`;
    }

    // Grant Card
    let card = null;
    try {
        if (r.cardRarity) {
            card = GameLogic.generateCard(r.cardRarity);
            if (card) {
                msg += `\n+1 ${card.name}!`;
            } else {
                throw new Error("Card generation failed (invalid rarity or card could not be created).");
            }
        }

        // If a card was generated successfully, save to the inventory
        if (card) {
            await Firestore.addUserArrayItem('inventory', card);
        }
        
        // Perform updates if all successes
        await Firestore.updateUserData(updates);
        alert(msg.trim());
    } catch (error) {
        Utils.log('error', "Ultra roll grant failed:", error);
        alert(`Failed to grant rewards: ${error.message}`);
    } finally {
        // Ensure the UI state is updated after the attempt.
        UI.updateAll(); 
    }
},

    useTicket: async () => {
        const currentTickets = AppState.userData?.blackMarketTickets || 0;
        Utils.log('info', `[BlackMarket] Attempting to use ticket. Current tickets: ${currentTickets}`);

        if (currentTickets <= 0) {
            alert("No Black Market tickets available.");
            Utils.log('warn', '[BlackMarket] useTicket aborted: No tickets.');
            return;
        }

        Utils.disableButton(DOMElements.useMarketTicketBtn, "Using...");

        const updates = {
            blackMarketTickets: firebase.firestore.FieldValue.increment(-1), 
            ultraTokens: firebase.firestore.FieldValue.increment(1) 
        };

        try {
            Utils.log('info', '[BlackMarket] Calling Firestore.updateUserData with updates:', updates);
            await Firestore.updateUserData(updates);
            alert("Used Black Market Ticket! Received 1 Ultra Token.");
            Utils.log('info', '[BlackMarket] Successfully used ticket and updated Firestore.');
        } catch (error) {
            Utils.log('error', "[BlackMarket] Error using ticket:", error);
            alert("Failed to use Black Market Ticket. Please try again.");
        } finally {
            const button = document.getElementById('useMarketTicketBtn');
            if (button) Utils.enableButton(button, (AppState.userData?.blackMarketTickets || 0) > 0); 
        }
    },

    useUltraToken: async () => {
        if ((AppState.userData?.ultraTokens || 0) <= 0) {
            alert("No tokens.");
            return; 
        }

        const drops = Constants.ULTRA_TOKEN_DROPS;
        const totalWeight = Object.values(drops).reduce((s, w) => s + w, 0);
        let r = Math.random() * totalWeight;
        let item = null;

        // Weighted random selection of consumable
        for (const i in drops) {
            r -= drops[i];
            if (r <= 0) {
                item = i;
                break;
            }
        }

        if (!item) {
            alert("Error processing token drop.");
            return; 
        }

        const field = `consumables.${item}`;
        const updates = { 
            ultraTokens: firebase.firestore.FieldValue.increment(-1), 
            [field]: firebase.firestore.FieldValue.increment(1) 
        };

        try {
            await Firestore.updateUserData(updates);
            alert(`Received: ${Utils.capitalize(item.replace(/_/g, ' '))}!`);
        } catch (error) {
            Utils.log('error', "Use token failed:", error);
            alert("Use failed.");
        }
    },
    openCase: async (caseTypeName) => {
    const caseData = Constants.CASE_PROBABILITIES[caseTypeName];
    if (!caseData) return;
    if ((AppState.userData?.currency || 0) < caseData.cost) { alert(`Need ${caseData.cost} coins.`); return; }

    Utils.disableButton(DOMElements.caseButtonsContainer?.querySelectorAll('button'));

    let nextCardId = null;
    let winningCard = null;
    
    const db = AppState.db;
    const counterRef = db.collection('counters').doc('cardCounter');
    const userRef = db.collection('users').doc(AppState.currentUserId);

    try {
        // --- Transaction Start (Get ID, Deduct Cost) ---
        await db.runTransaction(async (transaction) => {
            const counterDoc = await transaction.get(counterRef);
            if (!counterDoc.exists) { throw "Counter document ('counters/cardCounter') not found!"; }
            nextCardId = (counterDoc.data()?.count || 0) + 1;

            const userDoc = await transaction.get(userRef);
            const currentCurrency = userDoc.data()?.currency || 0;
            if (currentCurrency < caseData.cost) { throw new Error(`Insufficient funds (${currentCurrency} < ${caseData.cost}).`); }

            transaction.update(counterRef, { count: nextCardId });
            transaction.update(userRef, { currency: firebase.firestore.FieldValue.increment(-caseData.cost) });
        });

        Utils.log('info', `Case opening: Got card ID ${nextCardId}, deducted ${caseData.cost} currency.`);

        // --- Determine Winning Card ---
        winningCard = GameLogic.generateCard(GameLogic.chooseCaseRarityWeighted(caseData.drops), nextCardId);
        
        // Ensure card generation worked
        if (!winningCard) {
            throw new Error("Internal error: Failed to generate the winning card object.");
        }
        Utils.log('info', `Winning item determined: ${winningCard.name} (${winningCard.rarity})`);

        // --- Save winnings to Firestore ---
        await Firestore.addUserArrayItem('inventory', winningCard);
        
        // Display the result to the user
        alert(`You received: ${winningCard.name} (${Utils.capitalize(winningCard.rarity)})!`);

    } catch (error) {
        Utils.log('error', "Case opening failed:", error);
        alert(`Case Opening Failed: ${error.message || error}`);
    } finally {
        Utils.enableButton(DOMElements.caseButtonsContainer?.querySelectorAll('button'));
    }
},

    useConsumable: async (type) => {
        if ((Utils.getNestedProp(AppState.userData, `consumables.${type}`, 0)) <= 0) { 
            alert(`No ${type.replace(/_/g, ' ')} items.`); 
            return; 
        }

        const updates = { 
            [`consumables.${type}`]: firebase.firestore.FieldValue.increment(-1) 
        };

        try {
            await Firestore.updateUserData(updates);
            Utils.log('info', `Used consumable: ${type}`);
            
            // Trigger specific action based on type
            if (type === 'exclusive_case') await BlackMarket.handleExclusiveCase();
            else if (type === 'exclusive_luck_potion') Upgrades.startBoostTimer('exclusiveLuck');
            else if (type === 'ultra_lucky_roll') await BlackMarket.handleUltraLuckyRoll();
        } catch (error) { 
            Utils.log('error', `Use ${type} failed:`, error); 
            alert("Use failed."); 
        }
    },
    useExclusiveLuckPotion: async () => {
    const consumables = AppState.userData?.consumables || {};
    if (consumables.exclusive_luck_potion <= 0) {
        alert("No Exclusive Luck Potions available.");
        return; 
    }

    const updates = { [`consumables.exclusive_luck_potion`]: firebase.firestore.FieldValue.increment(-1) };
    
    try {
        await Firestore.updateUserData(updates); // Update Firestore
        AppState.activeBoosts.exclusiveLuck.active = true; // Activate the boost
        alert("Exclusive Luck Potion used! Luck has been boosted. Enjoy your rolls!");
    } catch (error) { 
        // Update all UI to reflect changes
        UI.updateAll(); 
    }
},

    handleUltraLuckyRoll: async () => {
        const r = Constants.ULTRA_LUCKY_ROLL_REWARDS;
        let msg = "Ultra Lucky Roll results:";
        const updates = {};
        
        // Grant Potions
        for (const p in r.potions) { 
            const c = r.potions[p];
            if (c > 0) { 
                updates[`potions.${p}`] = firebase.firestore.FieldValue.increment(c);
                msg += `\n+${c} ${Utils.capitalize(p)} Potion(s)`; 
            } 
        }

        // Grant Coins
        if (r.coins > 0) { 
            updates.currency = firebase.firestore.FieldValue.increment(r.coins); 
            msg += `\n+${r.coins} Coins`; 
        }

        // Grant Card
        let card = null;
        if (r.cardRarity) {
            card = GameLogic.generateCard(r.cardRarity);
            if (card) msg += `\n+1 ${card.name}!`;
            else msg += `\n(Card generation failed)`;
        }

        try {
            if (Object.keys(updates).length > 0) await Firestore.updateUserData(updates);
            if (card) await Firestore.addUserArrayItem('inventory', card);
            alert(msg.trim());
        } catch (error) { 
            Utils.log('error', "Ultra roll grant failed:", error); 
            alert("Failed to grant rewards."); 
        }
    }
};
// --- Redemption Module ---
const Redemption = {
    _cooldownInterval: null, 
    _lockoutInterval: null, 
    _isCheckingCode: false,

    initialize: () => {
        // Check sessionStorage for persisted unlock status
        if (sessionStorage.getItem('redemptionUnlocked') === 'true') {
            AppState.redemptionUnlocked = true;
            Utils.log('info', 'Redemption access restored from session storage.');
        }

        // Binding event listeners
        Utils.addListener(DOMElements.redemptionUnlockBtn, 'click', Redemption.handleUnlock);
        Utils.addListener(DOMElements.redemptionPasswordInput, 'keypress', (e) => { 
            if (e.key === 'Enter') Redemption.handleUnlock(); 
        });
        Utils.addListener(DOMElements.redeemCodeBtn, 'click', Redemption.handleRedeemCode);
        Utils.addListener(DOMElements.redemptionCodeInput, 'keypress', (e) => { 
            if (e.key === 'Enter') Redemption.handleRedeemCode(); 
        });
        Utils.addListener(DOMElements.submitReversalBtn, 'click', Redemption.handleSubmitReversal);
        Utils.addListener(DOMElements.reversalCodeInput, 'keypress', (e) => { 
            if (e.key === 'Enter') Redemption.handleSubmitReversal(); 
        });
        
        Redemption.updateRedemptionUI(); // Initial UI setup based on state
    },

    updateRedemptionUI: () => {
        const rData = AppState.userData?.redemption || { 
            isLockedOut: false, 
            lockoutUntilTimestamp: 0, 
            lastAttemptTimestamp: 0 
        };
        const now = Date.now();

        // Clear existing timers before setting new ones
        if (Redemption._cooldownInterval) clearInterval(Redemption._cooldownInterval);
        if (Redemption._lockoutInterval) clearInterval(Redemption._lockoutInterval);
        if (!DOMElements.redemptionPasswordPrompt) return; // Ensure elements exist

        if (AppState.redemptionUnlocked) {
            Utils.hideElement(DOMElements.redemptionPasswordPrompt); 
            Utils.showElement(DOMElements.redemptionInterface);
            let status = "Enter code.";
            let canRedeem = true;

            // Check for lockout status
            if (rData.isLockedOut && rData.lockoutUntilTimestamp > now) {
                status = "Account locked.";
                canRedeem = false;
                Redemption.startLockoutTimer(rData.lockoutUntilTimestamp);
                Utils.showElement(DOMElements.redemptionLockout); 
                Utils.hideElement(DOMElements.redemptionCooldown); 
                Utils.hideElement(DOMElements.reversalCodePrompt);
            } else {
                Utils.hideElement(DOMElements.redemptionLockout);
                // Cooldown status check
                const cooldownLeft = (rData.lastAttemptTimestamp + Constants.REDEMPTION_COOLDOWN_MS) - now;
                if (cooldownLeft > 0) {
                    status = "On cooldown."; 
                    canRedeem = false;
                    Redemption.startCooldownTimer(rData.lastAttemptTimestamp + Constants.REDEMPTION_COOLDOWN_MS);
                    Utils.showElement(DOMElements.redemptionCooldown);
                } else Utils.hideElement(DOMElements.redemptionCooldown);
                
                // Hide reversal prompt if not on cooldown or locked
                Utils.hideElement(DOMElements.reversalCodePrompt);
            }

            if (DOMElements.redemptionStatus) DOMElements.redemptionStatus.textContent = status;
            Utils.enableButton(DOMElements.redeemCodeBtn, canRedeem && !Redemption._isCheckingCode); // Enable redeem button if eligible
            if (DOMElements.redemptionCodeInput) DOMElements.redemptionCodeInput.disabled = !canRedeem;

        } else {
            Utils.showElement(DOMElements.redemptionPasswordPrompt); 
            Utils.hideElement(DOMElements.redemptionInterface);
        }
    },

    startCooldownTimer: (endTime) => {
        const update = () => {
            const rem = Math.max(0, endTime - Date.now());
            if (rem <= 0) {
                clearInterval(Redemption._cooldownInterval); 
                Redemption._cooldownInterval = null; 
                Redemption.updateRedemptionUI(); // Update UI when cooldown ends
            } else if (DOMElements.redemptionCooldown) {
                DOMElements.redemptionCooldown.textContent = `Cooldown: ${Utils.formatTimeRemaining(rem)}`;
            }
        };
        Redemption._cooldownInterval = setInterval(update, 1000); 
        update(); // Initial call
    },

    startLockoutTimer: (endTime) => {
        const update = () => {
            const rem = Math.max(0, endTime - Date.now());
            if (rem <= 0) {
                clearInterval(Redemption._lockoutInterval); 
                Redemption._lockoutInterval = null;
                // Check if lockout flag is still set in Firestore (in case of race condition)
                if (AppState.userData?.redemption?.isLockedOut) {
                    Firestore.updateUserData({ 
                        'redemption.isLockedOut': false, 
                        'redemption.lockoutUntilTimestamp': 0 
                    }).finally(Redemption.updateRedemptionUI); // Clear flag and refresh UI
                } else {
                    Redemption.updateRedemptionUI(); // Just refresh UI
                }
            } else if (DOMElements.redemptionLockout) {
                DOMElements.redemptionLockout.textContent = `Locked Out: ${Utils.formatTimeRemaining(rem)}`;
            }
        }; 
        Redemption._lockoutInterval = setInterval(update, 1000); 
        update(); // Initial call
    },

    handleUnlock: async () => {
        const passwordInput = DOMElements.redemptionPasswordInput;
        const password = passwordInput.value.trim();
        const unlockButton = DOMElements.redemptionUnlockBtn;
        const statusElement = DOMElements.redemptionStatus; // Get the status element

        if (!password) {
            if (statusElement) statusElement.textContent = "Please enter the access password.";
            return;
        }

        Utils.disableButton(unlockButton, "Verifying...");
        if (statusElement) statusElement.textContent = "Verifying..."; // Update status

        try {
            Utils.log('info', `Attempting to fetch redemption password from Firestore config/redemption`);
            const configRef = AppState.db.collection('config').doc('redemption');
            const configDoc = await configRef.get();

            if (!configDoc.exists || !configDoc.data()?.accessPassword) {
                 Utils.log('error', "Redemption config document 'config/redemption' or 'accessPassword' field not found in Firestore.");
                 if (statusElement) statusElement.textContent = "Configuration error. Cannot verify access.";
                 return; // Exit early
            }

            const correctPassword = configDoc.data().accessPassword;
            Utils.log('info', `Comparing entered password with fetched password.`);

            if (password === correctPassword) {
                Utils.log('info', 'Redemption access password verified successfully via Firestore.');
                AppState.redemptionUnlocked = true;
                sessionStorage.setItem('redemptionUnlocked', 'true'); // Persist unlock state for the session
                Utils.hideElement(DOMElements.redemptionPasswordPrompt);
                Utils.showElement(DOMElements.redemptionInterface);
                if (statusElement) statusElement.textContent = "Access granted. Enter code to redeem.";
            } else {
                Utils.log('warn', 'Incorrect redemption access password entered.');
                if (statusElement) statusElement.textContent = "Incorrect access password.";
                passwordInput.value = ''; // Clear the input
                passwordInput.focus();
            }
        } catch (error) {
            Utils.log('error', "Error fetching redemption config from Firestore:", error);
            if (statusElement) {
                if (error.code === 'permission-denied') {
                     statusElement.textContent = "Error: Insufficient permissions to check access.";
                } else {
                     statusElement.textContent = "Error verifying access. Please try again.";
                }
            }
        } finally {
            Utils.enableButton(unlockButton, "Unlock");
        }
    },

    handleRedeemCode: async () => {
    const codeInput = DOMElements.redemptionCodeInput;
    const code = codeInput.value.trim().toUpperCase();
    const redeemButton = DOMElements.redeemCodeBtn;
    const statusElement = DOMElements.redemptionStatus;
    const userId = AppState.currentUserId;

    if (!code) {
        if (statusElement) statusElement.textContent = "Please enter a code.";
        return;
    }
    if (!userId) {
         if (statusElement) statusElement.textContent = "Error: Not logged in.";
         return;
    }

    Utils.disableButton(redeemButton, "Redeeming...");
    if (statusElement) statusElement.textContent = "Checking code...";
    // Clear previous timers
    if (Redemption._cooldownInterval) clearInterval(Redemption._cooldownInterval);
    if (Redemption._lockoutInterval) clearInterval(Redemption._lockoutInterval);
    if (DOMElements.redemptionCooldown) DOMElements.redemptionCooldown.textContent = '';
    if (DOMElements.redemptionLockout) DOMElements.redemptionLockout.textContent = '';

    const codeRef = AppState.db.collection('redemptionCodes').doc(code);
    const userRef = AppState.db.collection('users').doc(userId);

    try {
        let rewardMessages = [];
        await AppState.db.runTransaction(async (transaction) => {
            Utils.log('info', `[Transaction] Checking code: ${code}`);
            const codeDoc = await transaction.get(codeRef);

            if (!codeDoc.exists) {
                throw new Error("Failed to redeem: Invalid code.");
            }

            const codeData = codeDoc.data();

            // Check if used
            if (codeData.usedBy) {
                throw new Error("Failed to redeem: Code already redeemed.");
            }

            // Check expiration
            if (codeData.expiresAt && codeData.expiresAt.toDate() < new Date()) {
                throw new Error("Expired: This code has expired.");
            }

            // --- Grant Reward Logic ---
            let itemsToGrant = [];
            if (codeData.itemData) {
                try {
                    itemsToGrant = JSON.parse(codeData.itemData);
                    if (!Array.isArray(itemsToGrant)) throw new Error("Parsed itemData is not an array.");
                } catch (parseError) {
                    throw new Error("Failed to redeem: Error processing reward data.");
                }
            } else {
                throw new Error("Failed to redeem: Code has no reward data.");
            }

            let userUpdates = {};
            for (const item of itemsToGrant) {
                if (!item || !item.type || !item.value) continue;
                let msg = item.text || `${item.value} ${item.type}`;
                rewardMessages.push(msg);

                if (item.type === 'currency') {
                    userUpdates.currency = firebase.firestore.FieldValue.increment(parseInt(item.value));
                } else if (item.type === 'case' || item.type === 'potion' || item.type === 'consumable') {
                    const field = `consumables.${item.value}`;
                    userUpdates[field] = firebase.firestore.FieldValue.increment(1);
                } else if (item.type === 'card') {
                    rewardMessages.push(`(Card reward '${item.value}' generation skipped - requires Cloud Function)`);
                }
            }

            if (Object.keys(userUpdates).length > 0) {
                transaction.update(userRef, userUpdates);
            }
            transaction.update(codeRef, {
                usedBy: userId,
                usedTimestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
        });

        // Success
        if (statusElement) {
            if (rewardMessages.length)
                statusElement.textContent = `Redeemed! You received: ${rewardMessages.join(', ')}`;
            else
                statusElement.textContent = `Redeemed! Reward granted.`;
        }
        codeInput.value = '';

    } catch (error) {
        // Differentiate expired, failed, and already redeemed
        let msg = "Failed to redeem.";
        if (error.message.includes("expired")) {
            msg = "Expired: This code has expired.";
        } else if (error.message.includes("Invalid code")) {
            msg = "Failed to redeem: Invalid code.";
        } else if (error.message.includes("already redeemed")) {
            msg = "Failed to redeem: Code already redeemed.";
        } else if (error.message.includes("reward data")) {
            msg = error.message;
        }
        if (statusElement) statusElement.textContent = msg;
    } finally {
        Utils.enableButton(redeemButton, "Redeem");
    }
},
    _resetState: () => {
        // Reset UI elements related to redemption state
        Utils.hideElement(DOMElements.redemptionInterface);
        Utils.showElement(DOMElements.redemptionPasswordPrompt);
        DOMElements.redemptionPasswordInput.value = '';
        DOMElements.redemptionCodeInput.value = '';
        if (Redemption._cooldownInterval) clearInterval(Redemption._cooldownInterval);
        if (Redemption._lockoutInterval) clearInterval(Redemption._lockoutInterval);
        if (DOMElements.redemptionCooldown) DOMElements.redemptionCooldown.textContent = ''; // Clear display
        if (DOMElements.redemptionLockout) DOMElements.redemptionLockout.textContent = ''; // Clear display
    }
}; // End Redemption Module (ensure itâ€™s correctly closed)
const AdminPanel = {
    initialize: () => {
        AdminPanel.populateButtons();
        Utils.addListener(DOMElements.adminLoginBtn, 'click', AdminPanel.handlePassword);
        Utils.addListener(DOMElements.adminPasswordInput, 'keypress', (e) => { 
            if (e.key === 'Enter') AdminPanel.handlePassword(); 
        });
        Utils.addListener(DOMElements.adminCloseBtn, 'click', AdminPanel.closePanel);
        Utils.addListener(DOMElements.adminGenerateCodeBtn, 'click', AdminPanel.generateAndSaveCode);
        
        // Use event delegation for item buttons
        if (DOMElements.adminGeneratorSection) {
            Utils.addListener(DOMElements.adminGeneratorSection, 'click', AdminPanel.handleItemSelectionClick);
        }
    },
    
    populateButtons: () => {
        const createBtn = (type, value, text) => {
            const button = document.createElement('button');
            button.dataset.type = type;
            button.dataset.value = value;
            button.textContent = text;
            button.className = 'btn btn-small btn-secondary';
            return button;
        };

        const appendButtonsToSection = (section, fragment) => {
            if (section) {
                section.appendChild(fragment);
            }
        };

        // Populate Cases
        const caseFrag = document.createDocumentFragment();
        Object.keys(Constants.CASE_PROBABILITIES).forEach(c => 
            caseFrag.appendChild(createBtn('case', c, Utils.capitalize(c))
        ));
        appendButtonsToSection(DOMElements.adminCaseButtons, caseFrag);

        // Populate Potions
        const potFrag = document.createDocumentFragment();
        Constants.POTION_TYPES.forEach(p => 
            potFrag.appendChild(createBtn('potion', p, `${Utils.capitalize(p)} Potion`))
        );
        appendButtonsToSection(DOMElements.adminPotionButtons, potFrag);

        // Populate Cards (by rarity)
        const rarFrag = document.createDocumentFragment();
        Constants.RARITIES.forEach(r => 
            rarFrag.appendChild(createBtn('card', r.name, `${Utils.capitalize(r.name)} Card`))
        );
        appendButtonsToSection(DOMElements.adminRarityButtons, rarFrag);

        // Populate Black Market Consumables
        const bmFrag = document.createDocumentFragment();
        Object.keys(Constants.ULTRA_TOKEN_DROPS).forEach(bm => 
            bmFrag.appendChild(createBtn('consumable', bm, Utils.capitalize(bm.replace(/_/g, ' '))))
        );
        bmFrag.appendChild(createBtn('consumable', 'blackMarketTicket', 'BM Ticket')); // Manual add
        bmFrag.appendChild(createBtn('consumable', 'ultraToken', 'Ultra Token')); // Manual add

        appendButtonsToSection(DOMElements.adminBlackMarketButtons, bmFrag);
    },
    
    handleItemSelectionClick: (event) => {
        const button = event.target.closest('button[data-type]');
        if (button && AppState.adminPanel.isLoggedIn) {
            AdminPanel.selectItem(button.dataset.type, button.dataset.value, button.textContent);
        }
    },

    toggleVisibility: () => {
        AppState.adminPanel.isVisible = !AppState.adminPanel.isVisible;
        const show = AppState.adminPanel.isVisible;

        if (show) {
            AdminPanel.resetStateForOpening();
            AdminPanel.checkAdminAccess();
        } else {
            AppState.adminPanel.isLoggedIn = false;
        }
        
        if (show) {
            Utils.setActive(DOMElements.adminPanel); 
        } else { 
            Utils.setInactive(DOMElements.adminPanel); 
        }
    },

    resetStateForOpening: () => {
        AppState.adminPanel.selectedItems = []; 
        if (DOMElements.adminSelectionInfo) {
            DOMElements.adminSelectionInfo.textContent = 'Selected: None';
        }
        Utils.disableButton(DOMElements.adminGenerateCodeBtn);
        if (DOMElements.adminCodeOutput) {
            DOMElements.adminCodeOutput.innerHTML = '';
        }
    },

    checkAdminAccess: () => {
        const isAdmin = Utils.getNestedProp(AppState.userData, 'isAdmin', false);
        if (isAdmin) {
            Utils.hideElement(DOMElements.adminPasswordSection);
            Utils.showElement(DOMElements.adminGeneratorSection);
            AppState.adminPanel.isLoggedIn = true;
            Utils.log('info', 'Admin panel opened for admin user.');
        } else {
            Utils.log('warn', 'Non-admin user tried to open admin panel.');
            alert('Admin access required.');
            AppState.adminPanel.isVisible = false; 
            AppState.adminPanel.isLoggedIn = false;
            Utils.hideElement(DOMElements.adminGeneratorSection);
        }
    },

    handlePassword: () => {
        // This function is now obsolete
        Utils.log('warn', 'AdminPanel.handlePassword called, but password check is deprecated.');
    },

    showGenerator: () => {
        Utils.hideElement(DOMElements.adminPasswordSection);
        Utils.showElement(DOMElements.adminGeneratorSection);
        AdminPanel.resetStateForOpening();
    },

    selectItem: (type, value, text) => {
        if (!AppState.adminPanel.isLoggedIn) return;

        const selectedItems = AppState.adminPanel.selectedItems;
        const maxItems = 4;
        const itemSignature = `${type}-${value}`;

        const existingIndex = selectedItems.findIndex(item => `${item.type}-${item.value}` === itemSignature);

        if (existingIndex > -1) {
            selectedItems.splice(existingIndex, 1);
            Utils.log('info', `Admin item deselected: ${text}`);
        } else {
            if (selectedItems.length >= maxItems) {
                alert(`You can select a maximum of ${maxItems} items.`);
                return;
            }
            selectedItems.push({ type, value, text });
            Utils.log('info', `Admin item selected: ${text}`);
        }

        AdminPanel.updateSelectionInfo();
        Utils.enableButton(DOMElements.adminGenerateCodeBtn, selectedItems.length > 0);
        if (DOMElements.adminCodeOutput) {
            DOMElements.adminCodeOutput.innerHTML = ''; // Clear previous code output on selection change
        }
    },

    updateSelectionInfo: () => {
        const selectedItems = AppState.adminPanel.selectedItems;
        if (DOMElements.adminSelectionInfo) {
            if (selectedItems.length > 0) {
                DOMElements.adminSelectionInfo.textContent = `Selected: ${selectedItems.map(i => i.text).join(', ')}`;
            } else {
                DOMElements.adminSelectionInfo.textContent = 'Selected: None';
            }
        }
    },

    generateUniqueCode: () => {
        return Array.from({ length: Constants.ADMIN_CODE_LENGTH }, () => 
            'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.charAt(Math.floor(Math.random() * 36))
        ).join('');
    },

    generateAndSaveCode: async () => {
        if (AppState.adminPanel.selectedItems.length === 0) {
            alert("No items selected.");
            return;
        }

        const generateBtn = DOMElements.adminGenerateCodeBtn;
        const outputDiv = DOMElements.adminCodeOutput;
        Utils.disableButton(generateBtn, "Generating...");
        outputDiv.textContent = "Generating code...";

        try {
            const code = AdminPanel.generateUniqueCode(); // use the new unique code generator
            const codeData = AdminPanel.prepareCodeData();

            // --- Add Expiration Date --- 
            await AdminPanel.setExpirationDate(codeData);

            await AppState.db.collection('redemptionCodes').doc(code).set(codeData);
            outputDiv.textContent = `Generated Code: ${code}`;
            Utils.log('info', `Admin ${AppState.currentUserId} generated code: ${code} with items: ${JSON.stringify(AppState.adminPanel.selectedItems)}` + (codeData.expiresAt ? ` expiring on: ${codeData.expiresAt.toDate()}` : ''));

            AdminPanel.clearSelection();
        } catch (error) {
            Utils.log('error', "Error generating redemption code:", error);
            outputDiv.textContent = "Error generating code.";
        } finally {
            Utils.enableButton(generateBtn, "Generate Code");
        }
    },

    prepareCodeData: () => {
        return {
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            createdBy: AppState.currentUserId,
            items: AppState.adminPanel.selectedItems,
            itemData: JSON.stringify(AppState.adminPanel.selectedItems),
            usedBy: null,
            usedTimestamp: null
        };
    },

    setExpirationDate: async (codeData) => {
        const expiryDateInput = DOMElements.adminExpiryDateInput;
        if (expiryDateInput && expiryDateInput.value) {
            try {
                const dateString = expiryDateInput.value;
                const localExpiryDate = new Date(dateString + 'T23:59:59.999');

                if (isNaN(localExpiryDate.getTime())) {
                    throw new Error("Invalid date selected.");
                }
                
                codeData.expiresAt = firebase.firestore.Timestamp.fromDate(localExpiryDate);
                Utils.log('info', `Expiration date set for code: ${localExpiryDate.toISOString()}`);
            } catch (dateError) {
                Utils.log('error', 'Error processing expiration date:', dateError);
                alert("Invalid expiration date format. Please select a valid date.");
                throw dateError; // Rethrow to stop generation
            }
        }
    },

    clearSelection: () => {
        AppState.adminPanel.selectedItems = [];
        AdminPanel.updateSelectionInfo();

        const expiryDateInput = DOMElements.adminExpiryDateInput;
        if (expiryDateInput) {
            expiryDateInput.value = '';
        }
    },

    displayCode: (code) => {
        if (DOMElements.adminCodeOutput) {
            DOMElements.adminCodeOutput.innerHTML = `<p>Generated Code:</p><strong>${code}</strong>`;
        }
    },
    
    closePanel: () => {
        AdminPanel.toggleVisibility();
    }
}; // End AdminPanel Module
// --- Profile Module (New) ---
const Profile = (() => {
    const WEEK_IN_MS = 7 * 24 * 60 * 60 * 1000;

    const showModal = () => {
        if (!AppState.currentUserId || !AppState.userData) {
            alert("Please log in first.");
            return;
        }
        const currentName = AppState.userData.displayName || "";
        DOMElements.newNameInput.value = currentName;

        const lastChange = AppState.userData.lastDisplayNameChange;
        let canChange = true;
        let statusMsg = "You can change your name.";

        if (lastChange && lastChange.toDate) { // Check if it's a Firestore Timestamp
            const lastChangeMs = lastChange.toDate().getTime();
            const nowMs = Date.now();
            const timeDiff = nowMs - lastChangeMs;

            if (timeDiff < WEEK_IN_MS) {
                canChange = false;
                const remainingMs = WEEK_IN_MS - timeDiff;
                const remainingDays = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                statusMsg = `You can change your name again in ${remainingDays} day(s).`;
            } else {
                 statusMsg = "You last changed your name more than 7 days ago. You can change it now.";
            }
        } else {
             statusMsg = "You haven't changed your name recently. You can change it now.";
        }

        DOMElements.profileStatusMsg.textContent = statusMsg;
        DOMElements.newNameInput.disabled = !canChange;
        DOMElements.saveNameBtn.disabled = !canChange;
        DOMElements.profileModal.classList.add('active');
    };

    const closeModal = () => {
        DOMElements.profileModal.classList.remove('active');
        DOMElements.profileStatusMsg.textContent = "Status: Loading..."; // Reset status
    };

    const changeDisplayName = async () => {
        const newName = DOMElements.newNameInput.value.trim();

        // Basic Validation
        if (!newName) {
            alert("Display name cannot be empty.");
            return;
        }
        if (newName.length > 25) {
             alert("Display name cannot exceed 25 characters.");
             return;
        }
        if (newName === AppState.userData.displayName) {
            alert("New name is the same as the current name.");
            return;
        }
        // Add profanity filter here if desired

        // Cooldown Check (redundant check, but good practice)
        const lastChange = AppState.userData.lastDisplayNameChange;
         if (lastChange && lastChange.toDate) {
            const timeDiff = Date.now() - lastChange.toDate().getTime();
            if (timeDiff < WEEK_IN_MS) {
                alert("You cannot change your name yet. Please wait for the cooldown.");
                return;
            }
         }

        Utils.disableButton(DOMElements.saveNameBtn, "Saving...");

        try {
            // Update Firebase Auth Profile
            const authUpdate = AppState.auth.currentUser.updateProfile({ displayName: newName });

            // Update Firestore User Document
            const firestoreUpdate = Firestore.updateUserData({
                displayName: newName,
                lastDisplayNameChange: firebase.firestore.FieldValue.serverTimestamp()
            });

            // Perform both updates concurrently
            await Promise.all([authUpdate, firestoreUpdate]);

            // Success
            AppState.userData.displayName = newName; // Update local state immediately
            AppState.userData.lastDisplayNameChange = new Date(); // Approx local update for UI
            // UI.updateUserGreeting(newName); // Incorrect function call
            if (DOMElements.userGreeting) { // Correct way to update greeting
                 DOMElements.userGreeting.innerText = `Welcome, ${newName}`;
            }
            alert("Display name updated successfully!");
            closeModal();

        } catch (error) {
            Utils.log('error', "Failed to update display name:", error);
            alert(`Error updating name: ${error.message}`);
            DOMElements.profileStatusMsg.textContent = "Error saving name. Please try again.";
        } finally {
            // Re-enable button (might be disabled in showModal if cooldown still active)
            showModal(); // Refresh modal state (will re-evaluate cooldown)
            // Ensure button enabled if modal is closed by error
             if (!DOMElements.profileModal.classList.contains('active')) {
                 Utils.enableButton(DOMElements.saveNameBtn);
             }
        }
    };

    const initialize = () => {
        if (DOMElements.profileBtn) {
             DOMElements.profileBtn.addEventListener('click', showModal);
        } else {
            Utils.log('warn', 'Profile button not found during init.');
        }
         if (DOMElements.saveNameBtn) {
            DOMElements.saveNameBtn.addEventListener('click', changeDisplayName);
        } else {
            Utils.log('warn', 'Save Name button not found during init.');
        }
        if (DOMElements.closeProfileBtn) {
             DOMElements.closeProfileBtn.addEventListener('click', closeModal);
        } else {
             Utils.log('warn', 'Close Profile button not found during init.');
        }
        Utils.log('info', 'Profile module initialized.');
    };

    return { initialize };

})();

// --- Application Initialization ---
const InitializeApp = () => {
    Utils.log('info', "InitializeApp STARTING..."); // <-- ADDED
    try {
        firebase.initializeApp(firebaseConfig);
        AppState.db = firebase.firestore();
        Utils.log('info', "Firebase Initialized.");
    } catch (e) {
        Utils.log('error', "FATAL: Firebase init failed:", e);
        alert("FATAL ERROR: Firebase initialization failed. Check console.");
        return;
    }
    UI.initializeBase();
    Auth.initialize(); // Setup auth listener and login form
    Utils.log('info', "InitializeApp FINISHED."); // <-- ADDED
};

// --- Run Initialization ---
InitializeApp(); // Ensure this line is present and not commented out at the end
    </script>

</body>
</html> 
